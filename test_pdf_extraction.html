<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDFæå–åŠŸèƒ½æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        .upload-area {
            border: 2px dashed #667eea;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #f9f9f9;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .upload-area:hover {
            background: #e6eafc;
            border-color: #5568d3;
        }
        .upload-area.dragover {
            background: #d4edda;
            border-color: #28a745;
        }
        input[type="file"] {
            display: none;
        }
        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        .btn:hover {
            background: #5568d3;
        }
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .result-area {
            margin-top: 30px;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 8px;
            display: none;
        }
        .result-section {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #667eea;
        }
        .result-section h3 {
            margin-top: 0;
            color: #667eea;
        }
        .result-item {
            margin: 10px 0;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
        }
        .result-label {
            font-weight: bold;
            color: #666;
            margin-right: 10px;
        }
        .result-value {
            color: #333;
        }
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        .loading.active {
            display: block;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .error {
            color: #dc3545;
            background: #f8d7da;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .success {
            color: #28a745;
            background: #d4edda;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        pre {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ“„ PDFæå–åŠŸèƒ½æµ‹è¯•</h1>
        <p>æ­¤å·¥å…·ç”¨äºæµ‹è¯•PDFæ–‡ä»¶çš„ä¿¡æ¯æå–åŠŸèƒ½ï¼ŒåŒ…æ‹¬æ ‡é¢˜ã€ä½œè€…ã€æ—¥æœŸç­‰ä¿¡æ¯çš„æå–ã€‚</p>
        
        <div class="upload-area" id="uploadArea">
            <p>ğŸ“ ç‚¹å‡»æˆ–æ‹–æ‹½PDFæ–‡ä»¶åˆ°è¿™é‡Œ</p>
            <p style="font-size: 12px; color: #666;">æ”¯æŒå•ä¸ªæˆ–å¤šä¸ªPDFæ–‡ä»¶</p>
        </div>
        <input type="file" id="fileInput" accept=".pdf" multiple>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>æ­£åœ¨å¤„ç†PDFæ–‡ä»¶...</p>
        </div>
        
        <div class="result-area" id="resultArea">
            <h2>æå–ç»“æœ</h2>
            <div id="results"></div>
        </div>
    </div>

    <!-- åŠ è½½pdf.jsåº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // åˆå§‹åŒ–pdf.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const loading = document.getElementById('loading');
        const resultArea = document.getElementById('resultArea');
        const resultsDiv = document.getElementById('results');

        // ç‚¹å‡»ä¸Šä¼ åŒºåŸŸ
        uploadArea.addEventListener('click', () => {
            fileInput.click();
        });

        // æ–‡ä»¶é€‰æ‹©
        fileInput.addEventListener('change', (e) => {
            handleFiles(Array.from(e.target.files));
        });

        // æ‹–æ”¾åŠŸèƒ½
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files).filter(f => f.name.toLowerCase().endsWith('.pdf'));
            if (files.length > 0) {
                handleFiles(files);
            }
        });

        // å¤„ç†æ–‡ä»¶
        async function handleFiles(files) {
            if (files.length === 0) return;

            loading.classList.add('active');
            resultArea.style.display = 'none';
            resultsDiv.innerHTML = '';

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                try {
                    const result = await extractPdfInfo(file);
                    displayResult(file.name, result, i === files.length - 1);
                } catch (error) {
                    displayError(file.name, error);
                }
            }

            loading.classList.remove('active');
            resultArea.style.display = 'block';
        }

        // æå–PDFä¿¡æ¯
        async function extractPdfInfo(file) {
            console.log('å¼€å§‹å¤„ç†PDFæ–‡ä»¶:', file.name);

            // è¯»å–æ–‡ä»¶ä¸ºArrayBuffer
            const arrayBuffer = await file.arrayBuffer();

            // åŠ è½½PDF
            const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
            const pdf = await loadingTask.promise;

            console.log('PDFåŠ è½½æˆåŠŸï¼Œæ€»é¡µæ•°:', pdf.numPages);

            // æå–å…ƒæ•°æ®
            const metadata = await pdf.getMetadata();
            const info = metadata.info || {};

            console.log('æå–çš„å…ƒæ•°æ®:', info);

            // æå–æ–‡æœ¬å†…å®¹ï¼ˆå‰5é¡µï¼‰
            let fullText = '';
            let firstPageText = '';
            const maxPages = Math.min(pdf.numPages, 5);

            for (let i = 1; i <= maxPages; i++) {
                try {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + ' ';

                    if (i === 1) {
                        firstPageText = pageText;
                    }

                    console.log(`ç¬¬${i}é¡µæ–‡æœ¬é•¿åº¦:`, pageText.length);
                } catch (error) {
                    console.warn(`è¯»å–ç¬¬${i}é¡µå¤±è´¥:`, error);
                }
            }

            // æ£€æµ‹æ˜¯å¦æ˜¯æ‰«æä»¶ï¼ˆæ–‡æœ¬å¤ªå°‘ï¼‰
            const isScanned = fullText.trim().length < 100;
            console.log('æ˜¯å¦æ‰«æä»¶:', isScanned, 'æ–‡æœ¬é•¿åº¦:', fullText.trim().length);

            // æå–æ ‡é¢˜
            let title = info.Title || '';
            console.log('[æ ‡é¢˜æå–] å¼€å§‹æå–æ ‡é¢˜ï¼Œå…ƒæ•°æ®æ ‡é¢˜:', title);
            
            // æ£€æŸ¥æ ‡é¢˜æ˜¯å¦åƒæ–‡ä»¶åæˆ–æ— æ•ˆæ ‡é¢˜ï¼ˆå¦‚DOIã€ç¼–å·ç­‰ï¼‰
            const isFilename = title && (title.toLowerCase().endsWith('.pdf') || title.includes('\\') || title.includes('/'));
            // æ£€æŸ¥æ˜¯å¦åƒDOIæˆ–ç¼–å·ï¼ˆå¦‚ "D5NR03036F 1..11 ++"ï¼‰
            const isInvalidTitle = title && (
                /^[A-Z0-9]+\s*\d+\.\.\d+/.test(title) || // å¦‚ "D5NR03036F 1..11"
                /^[A-Z0-9]+\s*\+\+/.test(title) || // å¦‚ "D5NR03036F ++"
                /^[A-Z0-9]{5,}\s*[\d\.\+\-]+$/.test(title) || // å¦‚ "D5NR03036F 1..11 ++"
                /^\d+[A-Z]+\d+/.test(title) // å¦‚ "10.1039/d5nr03036f"
            );
            console.log('[æ ‡é¢˜æå–] æ˜¯å¦åƒæ–‡ä»¶å:', isFilename, 'æ˜¯å¦æ— æ•ˆæ ‡é¢˜:', isInvalidTitle);
            
            if (isFilename || isInvalidTitle || !title || title.length < 10) {
                console.log('[æ ‡é¢˜æå–] ä»ç¬¬ä¸€é¡µæ–‡æœ¬æå–æ ‡é¢˜ï¼Œç¬¬ä¸€é¡µæ–‡æœ¬é•¿åº¦:', firstPageText.length);
                // ä»ç¬¬ä¸€é¡µæ–‡æœ¬æå–æ ‡é¢˜ï¼ˆæ”¹è¿›ç‰ˆï¼Œæ”¯æŒæ›´å¤æ‚çš„æ ‡é¢˜æ ¼å¼ï¼‰
                // æ”¹è¿›ï¼šå¦‚æœæ–‡æœ¬æ²¡æœ‰æ¢è¡Œç¬¦ï¼Œå°è¯•æŒ‰å¤šä¸ªç©ºæ ¼æˆ–ç‰¹å®šæ¨¡å¼åˆ†å‰²
                let firstPageLines = firstPageText.split(/\n+/).filter(line => line.trim().length > 0);
                
                // å¦‚æœåªæœ‰ä¸€è¡Œï¼Œå°è¯•æŒ‰å¤šä¸ªç©ºæ ¼æˆ–ç‰¹å®šæ¨¡å¼åˆ†å‰²
                if (firstPageLines.length === 1 && firstPageLines[0].length > 200) {
                    console.log('[æ ‡é¢˜æå–] æ£€æµ‹åˆ°å•è¡Œæ–‡æœ¬ï¼Œå°è¯•æ™ºèƒ½åˆ†å‰²...');
                    const longLine = firstPageLines[0];
                    // å°è¯•æŒ‰å¤šä¸ªè¿ç»­ç©ºæ ¼åˆ†å‰²
                    firstPageLines = longLine.split(/\s{3,}/).filter(line => line.trim().length > 0);
                    // å¦‚æœè¿˜æ˜¯å¤ªé•¿ï¼Œå°è¯•æŒ‰ç‰¹å®šå…³é”®è¯åˆ†å‰²
                    if (firstPageLines.length === 1) {
                        const parts = longLine.split(/\s+(?:DOI|Received|Accepted|Published|Cite this|PAPER|View Article)/i);
                        if (parts.length > 1) {
                            firstPageLines = parts.filter(line => line.trim().length > 0);
                        }
                    }
                    console.log('[æ ‡é¢˜æå–] æ™ºèƒ½åˆ†å‰²åè¡Œæ•°:', firstPageLines.length);
                }
                
                console.log('[æ ‡é¢˜æå–] ç¬¬ä¸€é¡µæ€»è¡Œæ•°:', firstPageLines.length);
                
                // æ”¹è¿›ï¼šä»åŸå§‹æ–‡æœ¬ä¸­ç›´æ¥æå–æ ‡é¢˜ï¼ˆæ›´å¯é ï¼Œæ”¯æŒåˆå¹¶è¢«åˆ†å‰²çš„æ ‡é¢˜ï¼‰
                console.log('[æ ‡é¢˜æå–] å°è¯•ä»åŸå§‹æ–‡æœ¬ç›´æ¥æå–æ ‡é¢˜...');
                
                // æŸ¥æ‰¾æ ‡é¢˜åŒºåŸŸï¼ˆåœ¨DOI/Receivedä¹‹å‰ï¼Œè·³è¿‡æœŸåˆŠåç­‰ï¼‰
                const titleEndMarkers = ['DOI:', 'doi:', 'Received', 'Accepted', 'Published', 'Cite this'];
                let titleStartIndex = 0;
                let titleEndIndex = firstPageText.length;
                
                // æŸ¥æ‰¾æ ‡é¢˜ç»“æŸä½ç½®
                for (const marker of titleEndMarkers) {
                    const index = firstPageText.indexOf(marker);
                    if (index > 0 && index < titleEndIndex) {
                        titleEndIndex = index;
                    }
                }
                
                // è·³è¿‡æœŸåˆŠåã€PAPERç­‰
                const skipPatterns = ['Nanoscale', 'PAPER', 'Cite this'];
                for (const pattern of skipPatterns) {
                    const index = firstPageText.indexOf(pattern);
                    if (index >= 0 && index < titleEndIndex) {
                        // æ‰¾åˆ°æ¨¡å¼åï¼Œç»§ç»­æŸ¥æ‰¾è¯¥æ¨¡å¼åçš„å†…å®¹
                        const afterPattern = firstPageText.substring(index + pattern.length);
                        // è·³è¿‡å¯èƒ½çš„å†’å·ã€ç©ºæ ¼ç­‰
                        const cleanStart = afterPattern.replace(/^[\s:]*/, '');
                        titleStartIndex = Math.max(titleStartIndex, index + pattern.length + (afterPattern.length - cleanStart.length));
                    }
                }
                
                // æå–æ ‡é¢˜å€™é€‰åŒºåŸŸ
                console.log('[æ ‡é¢˜æå–] æ ‡é¢˜åŒºåŸŸç´¢å¼•æ£€æŸ¥: titleStartIndex=', titleStartIndex, 'titleEndIndex=', titleEndIndex);
                
                if (titleEndIndex > titleStartIndex) {
                    let titleCandidate = firstPageText.substring(titleStartIndex, titleEndIndex).trim();
                    console.log('[æ ‡é¢˜æå–] æ ‡é¢˜åŒºåŸŸç´¢å¼•:', titleStartIndex, 'åˆ°', titleEndIndex, 'æ€»é•¿åº¦:', titleCandidate.length);
                    console.log('[æ ‡é¢˜æå–] æå–çš„æ ‡é¢˜å€™é€‰åŒºåŸŸï¼ˆå‰500å­—ç¬¦ï¼‰:', titleCandidate.substring(0, 500));
                    
                    // æ”¹è¿›ï¼šåœ¨å€™é€‰åŒºåŸŸä¸­æŸ¥æ‰¾ä½œè€…åä½ç½®ï¼Œæå‰æˆªæ–­
                    // ä½œè€…åæ¨¡å¼ï¼šè‡³å°‘ä¸¤ä¸ªå¤§å†™å­—æ¯å¼€å¤´çš„åå­—ï¼Œå¯èƒ½åŒ…å«é€—å·ã€ä¸Šä¸‹æ ‡æ ‡è®°ç­‰
                    const authorPatternInText = /([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?(?:\s*[a-z\s,]*\s*[A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)*(?:\s+and\s+[A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)?)/;
                    const authorMatch = titleCandidate.match(authorPatternInText);
                    if (authorMatch && authorMatch.index > 50) {
                        // å¦‚æœæ‰¾åˆ°ä½œè€…åä¸”ä½ç½®åˆç†ï¼ˆåœ¨æ ‡é¢˜ä¹‹åï¼‰ï¼Œæˆªæ–­æ ‡é¢˜å€™é€‰åŒºåŸŸ
                        titleCandidate = titleCandidate.substring(0, authorMatch.index).trim();
                        console.log('[æ ‡é¢˜æå–] æ£€æµ‹åˆ°ä½œè€…åï¼Œæˆªæ–­æ ‡é¢˜å€™é€‰åŒºåŸŸï¼Œæ–°é•¿åº¦:', titleCandidate.length);
                    }
                    
                    // æ”¹è¿›ï¼šå¦‚æœå€™é€‰åŒºåŸŸå¤ªçŸ­æˆ–çœ‹èµ·æ¥ä¸å®Œæ•´ï¼Œå°è¯•ä»å¤šè¡Œæ–‡æœ¬ä¸­æå–
                    // æ£€æŸ¥å€™é€‰åŒºåŸŸæ˜¯å¦åŒ…å«å®Œæ•´çš„æ ‡é¢˜ï¼ˆè‡³å°‘åŒ…å«ä¸€äº›å­¦æœ¯è¯æ±‡ï¼‰
                    const hasAcademicWords = titleCandidate && (
                        /(computational|screening|analysis|study|research|method|approach|system|model|algorithm|framework|design|development|evaluation|optimization|synthesis|reaction|catalyst|material|device|sensor|detection|recognition|classification|prediction|learning|network|neural|deep|machine|artificial|intelligence)/i.test(titleCandidate)
                    );
                    
                    if (!titleCandidate || titleCandidate.length < 20 || !hasAcademicWords) {
                        console.log('[æ ‡é¢˜æå–] å€™é€‰åŒºåŸŸä¸å®Œæ•´ï¼Œå°è¯•ä»å¤šè¡Œæ–‡æœ¬ä¸­æå–...');
                        // æŸ¥æ‰¾åŒ…å«å­¦æœ¯è¯æ±‡çš„è¡Œï¼Œå¹¶å‘å‰å›æº¯æŸ¥æ‰¾å¯èƒ½è¢«åˆ†å‰²çš„æ ‡é¢˜ç‰‡æ®µ
                        let foundTitleStart = false;
                        for (let i = 0; i < Math.min(15, firstPageLines.length); i++) {
                            const line = firstPageLines[i].trim();
                            // è·³è¿‡æ˜æ˜¾çš„éæ ‡é¢˜è¡Œ
                            if (line.match(/^(Nanoscale|PAPER|Cite this|DOI|doi|Received|Accepted|Published|rsc\.li)/i)) {
                                continue;
                            }
                            // æ”¹è¿›ï¼šæ›´æ—©åœ°æ£€æµ‹ä½œè€…åï¼ˆåŒ…æ‹¬å•ä¸ªä½œè€…ååè·Ÿé€—å·çš„æƒ…å†µï¼‰
                            const isAuthorLine = line.match(/^[A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?(?:\s*[,;]|\s+[a-z]\s*[,;]|\s+and\s+[A-Z][a-z]+)/);
                            if (isAuthorLine) {
                                console.log('[æ ‡é¢˜æå–] æ£€æµ‹åˆ°ä½œè€…è¡Œï¼Œåœæ­¢æå–:', line.substring(0, 50));
                                break;
                            }
                            
                            // æ”¹è¿›ï¼šæ£€æŸ¥æ˜¯å¦æ˜¯æ ‡é¢˜è¡Œï¼ˆåŒ…å«å°å†™å­—æ¯çš„å­¦æœ¯è¯æ±‡ï¼‰
                            const hasLowercase = line.match(/[a-z]/);
                            const hasAcademicWord = /(computational|screening|analysis|study|research|method|approach|system|model|algorithm|framework|design|development|evaluation|optimization|synthesis|reaction|catalyst|material|device|sensor|detection|recognition|classification|prediction|learning|network|neural|deep|machine|artificial|intelligence)/i.test(line);
                            const isShortFragment = line.length <= 5 && /^[\d\sA-Z\-]+$/.test(line); // çŸ­ç‰‡æ®µï¼Œå¯èƒ½æ˜¯è¢«åˆ†å‰²çš„æ ‡é¢˜
                            
                            // å¦‚æœæ‰¾åˆ°åŒ…å«å­¦æœ¯è¯æ±‡çš„è¡Œï¼Œæ ‡è®°æ ‡é¢˜å¼€å§‹
                            if (hasLowercase && (hasAcademicWord || line.length >= 20)) {
                                foundTitleStart = true;
                                if (!titleCandidate) {
                                    titleCandidate = line;
                                } else {
                                    titleCandidate += ' ' + line;
                                }
                            } 
                            // å¦‚æœå·²ç»åœ¨æ ‡é¢˜åŒºåŸŸï¼ŒçŸ­ç‰‡æ®µä¹Ÿå¯èƒ½æ˜¯æ ‡é¢˜çš„ä¸€éƒ¨åˆ†
                            else if (foundTitleStart && isShortFragment) {
                                titleCandidate += line; // ç›´æ¥è¿æ¥ï¼Œä¸æ·»åŠ ç©ºæ ¼ï¼ˆå¦‚ "M" + "2" + "N" + "4"ï¼‰
                            }
                            // å¦‚æœå·²ç»åœ¨æ ‡é¢˜åŒºåŸŸï¼Œç»§ç»­çš„è¡Œä¹Ÿå¯èƒ½æ˜¯æ ‡é¢˜çš„ä¸€éƒ¨åˆ†
                            else if (foundTitleStart && hasLowercase && line.length >= 10) {
                                titleCandidate += ' ' + line;
                            }
                        }
                        console.log('[æ ‡é¢˜æå–] ä»å¤šè¡Œæ–‡æœ¬æå–çš„å€™é€‰åŒºåŸŸï¼ˆå‰300å­—ç¬¦ï¼‰:', titleCandidate ? titleCandidate.substring(0, 300) : '(ç©º)');
                    }
                    
                    // æ”¹è¿›ï¼šç›´æ¥ä½¿ç”¨å€™é€‰åŒºåŸŸï¼Œæ™ºèƒ½æ¸…ç†å’Œåˆå¹¶
                    // å…ˆç§»é™¤ä½œè€…åï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                    let cleanedCandidate = titleCandidate;
                    const authorMatch2 = cleanedCandidate.match(authorPatternInText);
                    if (authorMatch2 && authorMatch2.index > 30) {
                        cleanedCandidate = cleanedCandidate.substring(0, authorMatch2.index).trim();
                        console.log('[æ ‡é¢˜æå–] ä»å€™é€‰åŒºåŸŸç§»é™¤ä½œè€…åï¼Œæ–°é•¿åº¦:', cleanedCandidate.length);
                    }
                    
                    // ç§»é™¤æ˜æ˜¾çš„éæ ‡é¢˜éƒ¨åˆ†
                    cleanedCandidate = cleanedCandidate
                        .replace(/^(Nanoscale|PAPER|Cite this|DOI|doi|Received|Accepted|Published).*?/i, '')
                        .trim();
                    
                    // æ”¹è¿›ï¼šæ™ºèƒ½åˆå¹¶è¢«åˆ†å‰²çš„æ ‡é¢˜éƒ¨åˆ†
                    // å¤„ç†ç±»ä¼¼ "Computational screening of M   2 N   4   -C-type" çš„æƒ…å†µ
                    // å°†å¤šä¸ªç©ºæ ¼æ›¿æ¢ä¸ºå•ä¸ªç©ºæ ¼ï¼Œä½†ä¿ç•™çŸ­ç‰‡æ®µä¹‹é—´çš„è¿æ¥ï¼ˆå¦‚ "M   2 N   4" â†’ "M2N4"ï¼‰
                    let mergedTitle = '';
                    const parts = cleanedCandidate.split(/\s+/);
                    
                    for (let i = 0; i < parts.length; i++) {
                        const part = parts[i];
                        const nextPart = parts[i + 1];
                        
                        // å¦‚æœå½“å‰éƒ¨åˆ†æ˜¯çŸ­ç‰‡æ®µï¼ˆæ•°å­—ã€å­—æ¯ã€ç¬¦å·ï¼‰ï¼Œä¸”ä¸‹ä¸€ä¸ªéƒ¨åˆ†ä¹Ÿæ˜¯çŸ­ç‰‡æ®µï¼Œç›´æ¥è¿æ¥
                        if (part.length <= 3 && /^[\dA-Z\-]+$/.test(part) && 
                            nextPart && nextPart.length <= 3 && /^[\dA-Z\-]+$/.test(nextPart)) {
                            mergedTitle += part;
                        } 
                        // å¦‚æœå½“å‰éƒ¨åˆ†ä»¥è¿å­—ç¬¦ç»“å°¾æˆ–ä¸‹ä¸€ä¸ªéƒ¨åˆ†ä»¥è¿å­—ç¬¦å¼€å¤´ï¼Œç›´æ¥è¿æ¥
                        else if (part.endsWith('-') || (nextPart && nextPart.startsWith('-'))) {
                            mergedTitle += part;
                        }
                        // å¦‚æœå½“å‰éƒ¨åˆ†æ˜¯çŸ­ç‰‡æ®µä¸”å‰ä¸€ä¸ªéƒ¨åˆ†ä¹Ÿæ˜¯çŸ­ç‰‡æ®µï¼Œç›´æ¥è¿æ¥
                        else if (part.length <= 3 && /^[\dA-Z\-]+$/.test(part) && 
                                 mergedTitle.length > 0 && /[\dA-Z\-]$/.test(mergedTitle)) {
                            mergedTitle += part;
                        }
                        else {
                            mergedTitle += (mergedTitle ? ' ' : '') + part;
                        }
                    }
                    
                    // æ¸…ç†å¤šä½™ç©ºæ ¼
                    mergedTitle = mergedTitle.replace(/\s+/g, ' ').trim();
                    
                    // æ£€æŸ¥å¹¶ç§»é™¤æœ«å°¾çš„ä½œè€…åï¼ˆå¦‚æœè¯¯åŒ…å«ï¼‰
                    const authorSuffixPattern = /\s+([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)(?:\s*[,;]|\s+[a-z]\s*[,;]|\s+and\s+[A-Z][a-z]+)?$/;
                    const authorSuffixMatch = mergedTitle.match(authorSuffixPattern);
                    if (authorSuffixMatch && authorSuffixMatch.index > 50) {
                        mergedTitle = mergedTitle.substring(0, authorSuffixMatch.index).trim();
                        console.log('[æ ‡é¢˜æå–] ç§»é™¤æœ«å°¾çš„ä½œè€…å:', authorSuffixMatch[1]);
                    }
                    
                    // éªŒè¯æ ‡é¢˜æ˜¯å¦æœ‰æ•ˆ
                    if (mergedTitle.length >= 20 && mergedTitle.length <= 300 && mergedTitle.match(/[a-z]/)) {
                        title = mergedTitle;
                        console.log('[æ ‡é¢˜æå–] âœ“ ä»åŸå§‹æ–‡æœ¬æå–æ ‡é¢˜:', title);
                    } else {
                        console.log('[æ ‡é¢˜æå–] åŸå§‹æ–‡æœ¬æå–çš„æ ‡é¢˜æ— æ•ˆï¼Œé•¿åº¦:', mergedTitle.length, 'å†…å®¹:', mergedTitle.substring(0, 100));
                    }
                }
                
                // å¦‚æœä»åŸå§‹æ–‡æœ¬æå–å¤±è´¥ï¼Œå°è¯•ä»åŸå§‹æ–‡æœ¬ä¸­ç›´æ¥æœç´¢æ ‡é¢˜
                if (!title || title.length < 20) {
                    console.log('[æ ‡é¢˜æå–] åŸå§‹æ–‡æœ¬æå–å¤±è´¥ï¼Œå°è¯•ä»åŸå§‹æ–‡æœ¬ä¸­ç›´æ¥æœç´¢æ ‡é¢˜...');
                    // åœ¨åŸå§‹æ–‡æœ¬ä¸­æœç´¢åŒ…å«å­¦æœ¯è¯æ±‡çš„é•¿æ–‡æœ¬ç‰‡æ®µï¼ˆåœ¨DOI/Receivedä¹‹å‰ï¼‰
                    const searchText = firstPageText.substring(0, Math.min(1000, firstPageText.length));
                    // æŸ¥æ‰¾åŒ…å« "computational" æˆ– "screening" çš„æ–‡æœ¬ç‰‡æ®µ
                    console.log('[æ ‡é¢˜æœç´¢] æœç´¢åŒºåŸŸé•¿åº¦:', searchText.length, 'å‰300å­—ç¬¦:', searchText.substring(0, 300));
                    const titleMatch = searchText.match(/(Computational\s+screening\s+of\s+[^J]+?)(?:\s+Jiaxiang\s+Wu|DOI|Received|Accepted)/i);
                    console.log('[æ ‡é¢˜æœç´¢] æ­£åˆ™åŒ¹é…ç»“æœ:', titleMatch ? 'æ‰¾åˆ°åŒ¹é…' : 'æœªæ‰¾åˆ°åŒ¹é…', titleMatch ? 'åŒ¹é…é•¿åº¦: ' + titleMatch[1].length : '');
                    if (titleMatch && titleMatch[1]) {
                        let candidateTitle = titleMatch[1].trim();
                        console.log('[æ ‡é¢˜æœç´¢] æå–çš„å€™é€‰æ ‡é¢˜ï¼ˆåŸå§‹ï¼‰:', candidateTitle);
                        
                        // æ”¹è¿›ï¼šä¿®å¤è¢«åˆ†å‰²çš„å•è¯ï¼ˆå¦‚ "fi rst" â†’ "first"ï¼‰
                        // åªä¿®å¤å·²çŸ¥çš„è¢«åˆ†å‰²å•è¯ï¼Œé¿å…è¯¯åˆå¹¶æ™®é€šå•è¯
                        console.log('[æ ‡é¢˜ä¿®å¤] å¼€å§‹ä¿®å¤è¢«åˆ†å‰²çš„å•è¯ï¼ŒåŸå§‹æ ‡é¢˜:', candidateTitle);
                        const splitWords = {
                            'fi rst': 'first',
                            'fi nancial': 'financial',
                            'fi nal': 'final',
                            'se cond': 'second',
                            'th ird': 'third',
                            'fo urth': 'fourth',
                            'fi fth': 'fifth',
                            'fi rst-principles': 'first-principles',
                            'fi nal': 'final'
                        };
                        
                        // å…ˆä¿®å¤å¸¦è¿å­—ç¬¦çš„è¢«åˆ†å‰²å•è¯ï¼ˆå¦‚ "fi rst-principles" â†’ "first-principles"ï¼‰
                        for (const [split, fixed] of Object.entries(splitWords)) {
                            if (split.includes('-')) {
                                const regex = new RegExp('\\b' + split.replace(/\s+/g, '\\s+') + '\\b', 'gi');
                                const before = candidateTitle;
                                candidateTitle = candidateTitle.replace(regex, fixed);
                                if (before !== candidateTitle) {
                                    console.log(`[æ ‡é¢˜ä¿®å¤] ä¿®å¤å¸¦è¿å­—ç¬¦çš„è¢«åˆ†å‰²å•è¯: "${split}" â†’ "${fixed}"`);
                                }
                            }
                        }
                        
                        // å†ä¿®å¤æ™®é€šçš„è¢«åˆ†å‰²å•è¯ï¼ˆå¦‚ "fi rst" â†’ "first"ï¼‰
                        for (const [split, fixed] of Object.entries(splitWords)) {
                            if (!split.includes('-')) {
                                const regex = new RegExp('\\b' + split.replace(/\s+/g, '\\s+') + '\\b', 'gi');
                                const before = candidateTitle;
                                candidateTitle = candidateTitle.replace(regex, fixed);
                                if (before !== candidateTitle) {
                                    console.log(`[æ ‡é¢˜ä¿®å¤] ä¿®å¤æ™®é€šçš„è¢«åˆ†å‰²å•è¯: "${split}" â†’ "${fixed}"`);
                                }
                            }
                        }
                        console.log('[æ ‡é¢˜ä¿®å¤] ä¿®å¤åçš„æ ‡é¢˜:', candidateTitle);
                        
                        // æ”¹è¿›ï¼šæ™ºèƒ½åˆå¹¶è¢«åˆ†å‰²çš„æ ‡é¢˜éƒ¨åˆ†
                        // å¤„ç†ç±»ä¼¼ "M   2 N   4" çš„æƒ…å†µï¼Œåˆå¹¶æˆ "M2N4"
                        console.log('[æ ‡é¢˜åˆå¹¶] å¼€å§‹åˆå¹¶æ ‡é¢˜ï¼ŒåŸå§‹å€™é€‰:', candidateTitle);
                        let mergedTitle = '';
                        const parts = candidateTitle.split(/\s+/).filter(p => p.length > 0); // è¿‡æ»¤ç©ºå­—ç¬¦ä¸²
                        console.log('[æ ‡é¢˜åˆå¹¶] åˆ†å‰²åçš„éƒ¨åˆ†æ•°é‡:', parts.length, 'éƒ¨åˆ†åˆ—è¡¨:', parts);
                        let prevPart = null; // è®°å½•å‰ä¸€ä¸ªéƒ¨åˆ†
                        
                        for (let i = 0; i < parts.length; i++) {
                            const part = parts[i];
                            const nextPart = parts[i + 1];
                            
                            // åˆ¤æ–­å½“å‰éƒ¨åˆ†æ˜¯å¦æ˜¯çŸ­ç‰‡æ®µï¼ˆçº¯æ•°å­—ã€å¤§å†™å­—æ¯ã€ç¬¦å·ï¼Œä¸åŒ…å«å°å†™å­—æ¯ï¼Œä¸”é•¿åº¦<=3ï¼‰
                            const isShortFragment = part.length <= 3 && /^[\dA-Z\-]+$/.test(part) && !/[a-z]/.test(part);
                            const isNextShortFragment = nextPart && nextPart.length <= 3 && /^[\dA-Z\-]+$/.test(nextPart) && !/[a-z]/.test(nextPart);
                            
                            // åˆ¤æ–­å‰ä¸€ä¸ªéƒ¨åˆ†æ˜¯å¦æ˜¯çŸ­ç‰‡æ®µ
                            const prevIsShortFragment = prevPart && prevPart.length <= 3 && /^[\dA-Z\-]+$/.test(prevPart) && !/[a-z]/.test(prevPart);
                            
                            // åˆ¤æ–­å‰ä¸€ä¸ªéƒ¨åˆ†æ˜¯å¦æ˜¯æ™®é€šå•è¯ï¼ˆåŒ…å«å°å†™å­—æ¯ï¼‰
                            const prevIsWord = prevPart && /[a-z]/.test(prevPart);
                            
                            console.log(`[æ ‡é¢˜åˆå¹¶] å¤„ç†ç¬¬${i + 1}éƒ¨åˆ†: "${part}"`, {
                                isShortFragment,
                                isNextShortFragment,
                                prevPart,
                                prevIsShortFragment,
                                prevIsWord,
                                mergedTitleBefore: mergedTitle
                            });
                            
                            // å¦‚æœå½“å‰éƒ¨åˆ†æ˜¯çŸ­ç‰‡æ®µï¼Œä½†å‰ä¸€ä¸ªéƒ¨åˆ†æ˜¯æ™®é€šå•è¯ï¼Œæ·»åŠ ç©ºæ ¼ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
                            if (isShortFragment && prevIsWord) {
                                mergedTitle += ' ' + part;
                                console.log(`[æ ‡é¢˜åˆå¹¶] è§„åˆ™1: çŸ­ç‰‡æ®µ+æ™®é€šå•è¯ï¼ˆå‰ä¸€ä¸ªï¼‰ï¼Œæ·»åŠ ç©ºæ ¼ï¼ŒmergedTitle: "${mergedTitle}"`);
                            }
                            // å¦‚æœå½“å‰éƒ¨åˆ†æ˜¯çŸ­ç‰‡æ®µï¼Œä¸”ä¸‹ä¸€ä¸ªéƒ¨åˆ†ä¹Ÿæ˜¯çŸ­ç‰‡æ®µï¼Œç›´æ¥è¿æ¥ï¼ˆä¸æ·»åŠ ç©ºæ ¼ï¼‰
                            else if (isShortFragment && isNextShortFragment) {
                                mergedTitle += part;
                                console.log(`[æ ‡é¢˜åˆå¹¶] è§„åˆ™2: çŸ­ç‰‡æ®µ+çŸ­ç‰‡æ®µï¼Œç›´æ¥è¿æ¥ï¼ŒmergedTitle: "${mergedTitle}"`);
                            } 
                            // å¦‚æœå½“å‰éƒ¨åˆ†æ˜¯çŸ­ç‰‡æ®µï¼Œä¸”å‰ä¸€ä¸ªéƒ¨åˆ†ä¹Ÿæ˜¯çŸ­ç‰‡æ®µï¼Œç›´æ¥è¿æ¥ï¼ˆä¸æ·»åŠ ç©ºæ ¼ï¼‰
                            else if (isShortFragment && prevIsShortFragment) {
                                mergedTitle += part;
                                console.log(`[æ ‡é¢˜åˆå¹¶] è§„åˆ™3: çŸ­ç‰‡æ®µ+çŸ­ç‰‡æ®µï¼ˆå‰ä¸€ä¸ªï¼‰ï¼Œç›´æ¥è¿æ¥ï¼ŒmergedTitle: "${mergedTitle}"`);
                            }
                            // å¦‚æœå½“å‰éƒ¨åˆ†ä»¥è¿å­—ç¬¦ç»“å°¾æˆ–ä¸‹ä¸€ä¸ªéƒ¨åˆ†ä»¥è¿å­—ç¬¦å¼€å¤´ï¼Œç›´æ¥è¿æ¥
                            else if (part.endsWith('-') || (nextPart && nextPart.startsWith('-'))) {
                                mergedTitle += part;
                                console.log(`[æ ‡é¢˜åˆå¹¶] è§„åˆ™4: è¿å­—ç¬¦ç›¸å…³ï¼Œç›´æ¥è¿æ¥ï¼ŒmergedTitle: "${mergedTitle}"`);
                            }
                            // å¦‚æœå½“å‰éƒ¨åˆ†æ˜¯æ™®é€šå•è¯ï¼Œå‰ä¸€ä¸ªéƒ¨åˆ†æ˜¯çŸ­ç‰‡æ®µï¼Œæ·»åŠ ç©ºæ ¼
                            else if (!isShortFragment && prevIsShortFragment) {
                                mergedTitle += ' ' + part;
                                console.log(`[æ ‡é¢˜åˆå¹¶] è§„åˆ™5: æ™®é€šå•è¯+çŸ­ç‰‡æ®µï¼ˆå‰ä¸€ä¸ªï¼‰ï¼Œæ·»åŠ ç©ºæ ¼ï¼ŒmergedTitle: "${mergedTitle}"`);
                            }
                            // å¦‚æœå½“å‰éƒ¨åˆ†æ˜¯æ™®é€šå•è¯ï¼Œå‰ä¸€ä¸ªéƒ¨åˆ†ä¹Ÿæ˜¯æ™®é€šå•è¯ï¼Œæ·»åŠ ç©ºæ ¼
                            else if (!isShortFragment && prevIsWord) {
                                mergedTitle += ' ' + part;
                                console.log(`[æ ‡é¢˜åˆå¹¶] è§„åˆ™6: æ™®é€šå•è¯+æ™®é€šå•è¯ï¼Œæ·»åŠ ç©ºæ ¼ï¼ŒmergedTitle: "${mergedTitle}"`);
                            }
                            // å¦‚æœå½“å‰éƒ¨åˆ†æ˜¯æ™®é€šå•è¯ï¼Œä¸”æ˜¯ç¬¬ä¸€ä¸ªéƒ¨åˆ†ï¼Œç›´æ¥æ·»åŠ 
                            else if (!isShortFragment && !prevPart) {
                                mergedTitle += part;
                                console.log(`[æ ‡é¢˜åˆå¹¶] è§„åˆ™7: ç¬¬ä¸€ä¸ªæ™®é€šå•è¯ï¼Œç›´æ¥æ·»åŠ ï¼ŒmergedTitle: "${mergedTitle}"`);
                            }
                            // å…¶ä»–æƒ…å†µï¼Œæ·»åŠ ç©ºæ ¼
                            else {
                                mergedTitle += (mergedTitle ? ' ' : '') + part;
                                console.log(`[æ ‡é¢˜åˆå¹¶] è§„åˆ™8: é»˜è®¤æƒ…å†µï¼Œæ·»åŠ ç©ºæ ¼ï¼ŒmergedTitle: "${mergedTitle}"`);
                            }
                            
                            // æ›´æ–°å‰ä¸€ä¸ªéƒ¨åˆ†
                            prevPart = part;
                        }
                        
                        console.log('[æ ‡é¢˜åˆå¹¶] åˆå¹¶å®Œæˆï¼Œæœ€ç»ˆæ ‡é¢˜:', mergedTitle);
                        
                        candidateTitle = mergedTitle;
                        console.log('[æ ‡é¢˜æ¸…ç†] åˆå¹¶åçš„æ ‡é¢˜:', candidateTitle);
                        
                        // æ£€æŸ¥å¹¶ç§»é™¤æœ«å°¾çš„ä½œè€…å
                        const authorSuffixMatch = candidateTitle.match(/\s+([A-Z][a-z]+\s+[A-Z][a-z]+)(?:\s*[,;]|\s+[a-z]\s*[,;])?$/);
                        if (authorSuffixMatch && authorSuffixMatch.index > 50) {
                            console.log('[æ ‡é¢˜æ¸…ç†] æ£€æµ‹åˆ°æœ«å°¾çš„ä½œè€…åï¼Œç§»é™¤:', authorSuffixMatch[1]);
                            candidateTitle = candidateTitle.substring(0, authorSuffixMatch.index).trim();
                            console.log('[æ ‡é¢˜æ¸…ç†] ç§»é™¤ä½œè€…ååçš„æ ‡é¢˜:', candidateTitle);
                        }
                        
                        console.log('[æ ‡é¢˜éªŒè¯] æ ‡é¢˜é•¿åº¦:', candidateTitle.length, 'æ˜¯å¦åŒ…å«å°å†™å­—æ¯:', /[a-z]/.test(candidateTitle));
                        if (candidateTitle.length >= 20 && candidateTitle.length <= 300) {
                            title = candidateTitle;
                            console.log('[æ ‡é¢˜æå–] âœ“ ä»åŸå§‹æ–‡æœ¬ç›´æ¥æœç´¢æ‰¾åˆ°æ ‡é¢˜:', title);
                        } else {
                            console.log('[æ ‡é¢˜éªŒè¯] âœ— æ ‡é¢˜éªŒè¯å¤±è´¥ï¼Œé•¿åº¦:', candidateTitle.length, 'å†…å®¹:', candidateTitle.substring(0, 100));
                        }
                    }
                }
                
                // å¦‚æœä»åŸå§‹æ–‡æœ¬æå–å¤±è´¥ï¼Œå°è¯•å¤šè¡Œåˆå¹¶
                if (!title || title.length < 20) {
                    console.log('[æ ‡é¢˜æå–] å°è¯•å¤šè¡Œåˆå¹¶æå–...');
                    let titleLines = [];
                    let inTitleSection = false;
                    let titleStartIndex = -1; // è®°å½•æ ‡é¢˜å¼€å§‹çš„è¡Œç´¢å¼•
                    
                    for (let lineIndex = 0; lineIndex < Math.min(30, firstPageLines.length); lineIndex++) {
                        const line = firstPageLines[lineIndex];
                        const trimmedLine = line.trim();
                        
                        console.log(`[æ ‡é¢˜æå–] æ£€æŸ¥ç¬¬${lineIndex + 1}è¡Œï¼Œé•¿åº¦:${trimmedLine.length}, å†…å®¹:`, trimmedLine.substring(0, 80));
                        
                        // è·³è¿‡æ˜æ˜¾çš„éæ ‡é¢˜è¡Œ
                        if (trimmedLine.match(/^(https?:\/\/|www\.|doi:|doi\.org|rsc\.li|Cite this|PAPER|View Article|View Journal|Check for updates|Received|Accepted|Published|DOI|Abstract|Introduction|Keywords|Author|Nanoscale)/i)) {
                            if (inTitleSection) {
                                // å¦‚æœå·²ç»åœ¨æ ‡é¢˜åŒºåŸŸï¼Œé‡åˆ°éæ ‡é¢˜è¡Œå°±åœæ­¢
                                break;
                            }
                            continue;
                        }
                        
                        // æ£€æŸ¥æ˜¯å¦æ˜¯æ ‡é¢˜è¡Œï¼ˆæ”¹è¿›ï¼šæ”¯æŒçŸ­è¡Œï¼Œå¯èƒ½æ˜¯è¢«åˆ†å‰²çš„æ ‡é¢˜çš„ä¸€éƒ¨åˆ†ï¼‰
                        const hasLowercase = trimmedLine.match(/[a-z]/);
                        const hasAcademicWord = /(computational|screening|analysis|study|research|method|approach|system|model|algorithm|framework|design|development|evaluation|optimization|synthesis|reaction|catalyst|material|device|sensor|detection|recognition|classification|prediction|learning|network|neural|deep|machine|artificial|intelligence)/i.test(trimmedLine);
                        // æ”¹è¿›ï¼šæ›´æ—©åœ°æ£€æµ‹ä½œè€…åï¼ˆåŒ…æ‹¬å•ä¸ªä½œè€…ååè·Ÿé€—å·ã€ä¸Šä¸‹æ ‡æ ‡è®°ç­‰ï¼‰
                        const isAuthorLine = trimmedLine.match(/^[A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?(?:\s*[,;]|\s+[a-z]\s*[,;]|\s+and\s+[A-Z][a-z]+)/) ||
                                           trimmedLine.match(/^[A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?(?:\s*[a-z\s,]*\s*[A-Z][a-z]+\s+[A-Z][a-z]+)/);
                        const isInstitution = trimmedLine.match(/\b(University|College|Institute|Department|Laboratory|Center|Centre)\b/i);
                        const isShortFragment = trimmedLine.length <= 5 && /^[\d\sA-Z\-]+$/.test(trimmedLine); // çŸ­ç‰‡æ®µï¼Œå¯èƒ½æ˜¯è¢«åˆ†å‰²çš„æ ‡é¢˜
                        const isNumberOrSymbol = trimmedLine.match(/^[\d\s\-]+$/); // çº¯æ•°å­—æˆ–ç¬¦å·ï¼Œå¯èƒ½æ˜¯è¢«åˆ†å‰²çš„æ ‡é¢˜
                        
                        // æ”¹è¿›ï¼šå¦‚æœæ£€æµ‹åˆ°ä½œè€…è¡Œï¼Œç«‹å³åœæ­¢ï¼ˆæ— è®ºæ˜¯å¦åœ¨æ ‡é¢˜åŒºåŸŸï¼‰
                        if (isAuthorLine) {
                            console.log(`[æ ‡é¢˜æå–] æ£€æµ‹åˆ°ä½œè€…è¡Œï¼Œåœæ­¢æå–ï¼Œç¬¬${lineIndex + 1}è¡Œ:`, trimmedLine.substring(0, 50));
                            break;
                        }
                        
                        // æ”¹è¿›ï¼šå¦‚æœæ£€æµ‹åˆ°åŒ…å«å­¦æœ¯è¯æ±‡çš„è¡Œï¼Œæ ‡è®°ä¸ºæ ‡é¢˜å¼€å§‹ï¼Œå¹¶å‘å‰å›æº¯æŸ¥æ‰¾å¯èƒ½è¢«åˆ†å‰²çš„æ ‡é¢˜ç‰‡æ®µ
                        if (!inTitleSection && hasLowercase && (hasAcademicWord || trimmedLine.length >= 20)) {
                            inTitleSection = true;
                            titleStartIndex = lineIndex;
                            console.log(`[æ ‡é¢˜æå–] æ£€æµ‹åˆ°æ ‡é¢˜å¼€å§‹ï¼Œç¬¬${lineIndex + 1}è¡Œï¼Œå‘å‰å›æº¯æŸ¥æ‰¾æ ‡é¢˜ç‰‡æ®µ...`);
                            
                            // æ”¹è¿›ï¼šå‘å‰å›æº¯æŸ¥æ‰¾å¯èƒ½è¢«åˆ†å‰²çš„æ ‡é¢˜ç‰‡æ®µï¼ˆæœ€å¤šå›æº¯15è¡Œï¼Œæ›´è¿œåœ°æŸ¥æ‰¾ï¼‰
                            let foundTitleStart = false;
                            let foundFullTitleLine = false;
                            for (let backIndex = lineIndex - 1; backIndex >= Math.max(0, lineIndex - 15); backIndex--) {
                                const backLine = firstPageLines[backIndex].trim();
                                
                                // è·³è¿‡æ˜æ˜¾çš„éæ ‡é¢˜è¡Œ
                                if (backLine.match(/^(https?:\/\/|www\.|doi:|doi\.org|rsc\.li|Cite this|PAPER|View Article|View Journal|Check for updates|Received|Accepted|Published|DOI|Abstract|Introduction|Keywords|Author|Nanoscale)/i)) {
                                    if (foundTitleStart) {
                                        // å¦‚æœå·²ç»æ‰¾åˆ°æ ‡é¢˜å¼€å§‹ï¼Œé‡åˆ°éæ ‡é¢˜è¡Œå°±åœæ­¢
                                        break;
                                    }
                                    continue;
                                }
                                
                                const backHasLowercase = backLine.match(/[a-z]/);
                                const backHasAcademicWord = /(computational|screening|analysis|study|research|method|approach|system|model|algorithm|framework|design|development|evaluation|optimization|synthesis|reaction|catalyst|material|device|sensor|detection|recognition|classification|prediction|learning|network|neural|deep|machine|artificial|intelligence)/i.test(backLine);
                                
                                // å¦‚æœæ˜¯çŸ­ç‰‡æ®µï¼ˆæ•°å­—ã€å­—æ¯ã€ç¬¦å·ï¼‰ï¼Œå¯èƒ½æ˜¯æ ‡é¢˜çš„ä¸€éƒ¨åˆ†
                                if (backLine.length <= 5 && /^[\d\sA-Z\-]+$/.test(backLine)) {
                                    titleLines.unshift(backLine); // æ’å…¥åˆ°å¼€å¤´
                                    console.log(`[æ ‡é¢˜æå–] å›æº¯æ‰¾åˆ°æ ‡é¢˜ç‰‡æ®µï¼Œç¬¬${backIndex + 1}è¡Œ:`, backLine);
                                    foundTitleStart = true;
                                } 
                                // å¦‚æœåŒ…å«å°å†™å­—æ¯å’Œå­¦æœ¯è¯æ±‡ï¼Œæ˜¯å®Œæ•´çš„æ ‡é¢˜è¡Œ
                                else if (backHasLowercase && (backHasAcademicWord || backLine.length >= 20)) {
                                    titleLines.unshift(backLine); // æ’å…¥åˆ°å¼€å¤´
                                    console.log(`[æ ‡é¢˜æå–] å›æº¯æ‰¾åˆ°æ ‡é¢˜è¡Œï¼Œç¬¬${backIndex + 1}è¡Œ:`, backLine.substring(0, 80));
                                    foundTitleStart = true;
                                    foundFullTitleLine = true;
                                    // ç»§ç»­å›æº¯ï¼ŒæŸ¥æ‰¾æ›´å‰é¢çš„æ ‡é¢˜ç‰‡æ®µï¼ˆå¯èƒ½è¿˜æœ‰æ›´å‰é¢çš„æ ‡é¢˜è¡Œï¼‰
                                }
                                // å¦‚æœåŒ…å«å°å†™å­—æ¯ä½†è¾ƒçŸ­ï¼Œä¹Ÿå¯èƒ½æ˜¯æ ‡é¢˜çš„ä¸€éƒ¨åˆ†
                                else if (backHasLowercase && backLine.length >= 10 && backLine.length < 20) {
                                    titleLines.unshift(backLine); // æ’å…¥åˆ°å¼€å¤´
                                    console.log(`[æ ‡é¢˜æå–] å›æº¯æ‰¾åˆ°æ ‡é¢˜ç‰‡æ®µï¼ˆçŸ­è¡Œï¼‰ï¼Œç¬¬${backIndex + 1}è¡Œ:`, backLine);
                                    foundTitleStart = true;
                                }
                                // å¦‚æœå·²ç»æ‰¾åˆ°å®Œæ•´çš„æ ‡é¢˜è¡Œï¼Œé‡åˆ°ç©ºè¡Œæˆ–éæ ‡é¢˜å†…å®¹ï¼Œåœæ­¢
                                else if (foundFullTitleLine && (backLine.length === 0 || !backHasLowercase)) {
                                    break;
                                }
                            }
                            
                            // æ·»åŠ å½“å‰è¡Œ
                            titleLines.push(trimmedLine);
                            console.log(`[æ ‡é¢˜æå–] ç¬¬${lineIndex + 1}è¡ŒåŠ å…¥æ ‡é¢˜å€™é€‰`);
                            continue;
                        }
                        
                        // å¦‚æœå·²ç»åœ¨æ ‡é¢˜åŒºåŸŸï¼ŒçŸ­è¡Œæˆ–æ•°å­—è¡Œå¯èƒ½æ˜¯æ ‡é¢˜çš„å»¶ç»­
                        if (inTitleSection && (isShortFragment || isNumberOrSymbol)) {
                            titleLines.push(trimmedLine);
                            console.log(`[æ ‡é¢˜æå–] ç¬¬${lineIndex + 1}è¡Œï¼ˆçŸ­ç‰‡æ®µï¼‰åŠ å…¥æ ‡é¢˜å€™é€‰`);
                            continue;
                        }
                        
                        // è·³è¿‡å¤ªçŸ­çš„è¡Œï¼ˆé™¤éæ˜¯æ ‡é¢˜çš„å»¶ç»­ï¼‰
                        if (trimmedLine.length < 5 && !inTitleSection) {
                            continue;
                        }
                        
                        if (hasLowercase && !isAuthorLine && !isInstitution && trimmedLine.length >= 20 && trimmedLine.length <= 400) {
                            titleLines.push(trimmedLine);
                            inTitleSection = true;
                            if (titleStartIndex === -1) titleStartIndex = lineIndex;
                            console.log(`[æ ‡é¢˜æå–] ç¬¬${lineIndex + 1}è¡ŒåŠ å…¥æ ‡é¢˜å€™é€‰`);
                        } else if (hasLowercase && !isAuthorLine && !isInstitution && trimmedLine.length >= 10 && trimmedLine.length < 20 && inTitleSection) {
                            // å¦‚æœå·²ç»åœ¨æ ‡é¢˜åŒºåŸŸï¼Œè¾ƒçŸ­çš„åŒ…å«å°å†™å­—æ¯çš„è¡Œä¹Ÿå¯èƒ½æ˜¯æ ‡é¢˜çš„ä¸€éƒ¨åˆ†
                            titleLines.push(trimmedLine);
                            console.log(`[æ ‡é¢˜æå–] ç¬¬${lineIndex + 1}è¡Œï¼ˆçŸ­è¡Œï¼‰åŠ å…¥æ ‡é¢˜å€™é€‰`);
                        } else if (inTitleSection && !hasLowercase && trimmedLine.length > 0 && trimmedLine.length < 20) {
                            // å¦‚æœå·²ç»åœ¨æ ‡é¢˜åŒºåŸŸï¼ŒçŸ­çš„éå°å†™è¡Œå¯èƒ½æ˜¯æ ‡é¢˜çš„å»¶ç»­ï¼ˆå¦‚ "2 N 4"ï¼‰
                            titleLines.push(trimmedLine);
                            console.log(`[æ ‡é¢˜æå–] ç¬¬${lineIndex + 1}è¡Œï¼ˆå»¶ç»­ï¼‰åŠ å…¥æ ‡é¢˜å€™é€‰`);
                        } else if (inTitleSection) {
                            // å¦‚æœå·²ç»åœ¨æ ‡é¢˜åŒºåŸŸï¼Œé‡åˆ°éæ ‡é¢˜è¡Œå°±åœæ­¢
                            break;
                        }
                    }
                    
                    // åˆå¹¶æ ‡é¢˜è¡Œï¼ˆæ”¹è¿›ï¼šæ™ºèƒ½åˆå¹¶ï¼Œå¤„ç†è¢«åˆ†å‰²çš„æ ‡é¢˜ï¼‰
                    if (titleLines.length > 0) {
                        // æ”¹è¿›ï¼šæ™ºèƒ½åˆå¹¶ï¼Œå¤„ç†è¢«åˆ†å‰²çš„æ ‡é¢˜ç‰‡æ®µ
                        let mergedTitle = '';
                        for (let i = 0; i < titleLines.length; i++) {
                            const currentLine = titleLines[i].trim();
                            if (i === 0) {
                                mergedTitle = currentLine;
                            } else {
                                const prevLine = titleLines[i - 1].trim();
                                // å¦‚æœå‰ä¸€è¡Œä»¥è¿å­—ç¬¦ç»“å°¾æˆ–å½“å‰è¡Œä»¥è¿å­—ç¬¦å¼€å¤´ï¼Œç›´æ¥è¿æ¥
                                if (prevLine.endsWith('-') || currentLine.startsWith('-')) {
                                    mergedTitle += currentLine;
                                } 
                                // æ”¹è¿›ï¼šå¦‚æœå‰ä¸€è¡Œä»¥å­—æ¯æˆ–æ•°å­—ç»“å°¾ï¼Œå½“å‰è¡Œä»¥å­—æ¯æˆ–æ•°å­—å¼€å¤´ï¼Œä¸”å‰ä¸€è¡Œå¾ˆçŸ­ï¼Œå¯èƒ½æ˜¯è¢«åˆ†å‰²çš„æ ‡é¢˜ï¼ˆå¦‚"M2"å’Œ"N4"ï¼‰
                                else if (prevLine.length <= 5 && 
                                         /[A-Z0-9]$/.test(prevLine.replace(/\s+/g, '')) && 
                                         /^[A-Z0-9]/.test(currentLine.replace(/\s+/g, ''))) {
                                    // ç§»é™¤ç©ºæ ¼åç›´æ¥è¿æ¥ï¼ˆå¦‚ "2 N" + "4" â†’ "2N4"ï¼‰
                                    mergedTitle += currentLine.replace(/\s+/g, '');
                                }
                                // æ”¹è¿›ï¼šå¦‚æœå‰ä¸€è¡Œæ˜¯çŸ­æ•°å­—/å­—æ¯ç»„åˆï¼ˆå¦‚ "2 N"ï¼‰ï¼Œå½“å‰è¡Œä¹Ÿæ˜¯çŸ­æ•°å­—/å­—æ¯ï¼ˆå¦‚ "4"ï¼‰ï¼Œå¯èƒ½æ˜¯åŒ–å­¦å¼æˆ–ç¼–å·
                                else if (prevLine.length <= 5 && 
                                         /^[\d\sA-Z\-]+$/.test(prevLine) && 
                                         currentLine.length <= 5 &&
                                         /^[\d\sA-Z\-]+$/.test(currentLine)) {
                                    // ç§»é™¤ç©ºæ ¼åç›´æ¥è¿æ¥
                                    mergedTitle += currentLine.replace(/\s+/g, '');
                                }
                                // æ”¹è¿›ï¼šå¦‚æœå‰ä¸€è¡Œä»¥ç©ºæ ¼ç»“å°¾çš„çŸ­ç‰‡æ®µï¼Œå½“å‰è¡Œä¹Ÿæ˜¯çŸ­ç‰‡æ®µï¼Œç›´æ¥è¿æ¥
                                else if (prevLine.length <= 5 && currentLine.length <= 5) {
                                    mergedTitle += currentLine.replace(/\s+/g, '');
                                }
                                else {
                                    mergedTitle += ' ' + currentLine;
                                }
                            }
                        }
                        // æ”¹è¿›ï¼šæ¸…ç†æ ‡é¢˜ï¼Œç§»é™¤ä½œè€…åï¼ˆå¦‚æœè¯¯åŒ…å«ï¼‰
                        // æ£€æŸ¥æœ«å°¾æ˜¯å¦åŒ…å«ä½œè€…åæ¨¡å¼
                        const authorSuffixPattern = /\s+([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)(?:\s*[,;]|\s+[a-z]\s*[,;]|\s+and\s+[A-Z][a-z]+)?$/;
                        const authorMatch = mergedTitle.match(authorSuffixPattern);
                        if (authorMatch && authorMatch.index > 50) {
                            // å¦‚æœæ‰¾åˆ°ä½œè€…åä¸”ä½ç½®åˆç†ï¼Œç§»é™¤å®ƒ
                            mergedTitle = mergedTitle.substring(0, authorMatch.index).trim();
                            console.log('[æ ‡é¢˜æå–] ç§»é™¤è¯¯åŒ…å«çš„ä½œè€…å:', authorMatch[1]);
                        }
                        
                        // æ¸…ç†å¤šä½™ç©ºæ ¼ï¼Œä½†ä¿ç•™å¿…è¦çš„ç©ºæ ¼
                        title = mergedTitle.replace(/\s+/g, ' ').trim();
                        if (title.length > 300) {
                            title = title.substring(0, 300).trim();
                        }
                        console.log('[æ ‡é¢˜æå–] âœ“ åˆå¹¶å¤šè¡Œæ ‡é¢˜:', title);
                    }
                }
                
                if (!title || title.length < 10) {
                    console.warn('[æ ‡é¢˜æå–] âœ— æœªèƒ½ä»æ–‡æœ¬æå–åˆ°æœ‰æ•ˆæ ‡é¢˜');
                }
            } else {
                console.log('[æ ‡é¢˜æå–] ä½¿ç”¨å…ƒæ•°æ®æ ‡é¢˜:', title);
            }

            // æå–ä½œè€…ä¿¡æ¯
            let author = info.Author || '';
            let firstAuthor = author.split(/[,;]/)[0]?.trim() || '';
            let allAuthors = author ? author.split(/[,;]/).map(a => a.trim()) : [];
            
            console.log('[ä½œè€…æå–] å¼€å§‹æå–ä½œè€…ï¼Œå…ƒæ•°æ®ä½œè€…:', author, 'ç¬¬ä¸€ä½œè€…:', firstAuthor);

            // ä»æ–‡æœ¬ä¸­æå–ä½œè€…ï¼ˆæ”¹è¿›ç‰ˆï¼Œæ”¯æŒä¸Šä¸‹æ ‡æ ‡è®°å’Œç‰¹æ®Šå­—ç¬¦ï¼‰
            if (!firstAuthor && fullText) {
                console.log('[ä½œè€…æå–] ä»ç¬¬ä¸€é¡µæ–‡æœ¬æå–ä½œè€…ï¼Œç¬¬ä¸€é¡µæ–‡æœ¬é•¿åº¦:', firstPageText.length);
                // å…ˆå°è¯•ä»ç¬¬ä¸€é¡µæå–ä½œè€…è¡Œï¼ˆé€šå¸¸åœ¨æ ‡é¢˜ä¹‹åï¼‰
                let firstPageLines = firstPageText.split(/\n+/).filter(line => line.trim().length > 0);
                
                // å¦‚æœåªæœ‰ä¸€è¡Œï¼Œå°è¯•æŒ‰å¤šä¸ªç©ºæ ¼æˆ–ç‰¹å®šæ¨¡å¼åˆ†å‰²
                if (firstPageLines.length === 1 && firstPageLines[0].length > 200) {
                    console.log('[ä½œè€…æå–] æ£€æµ‹åˆ°å•è¡Œæ–‡æœ¬ï¼Œå°è¯•æ™ºèƒ½åˆ†å‰²...');
                    const longLine = firstPageLines[0];
                    // å°è¯•æŒ‰å¤šä¸ªè¿ç»­ç©ºæ ¼åˆ†å‰²
                    firstPageLines = longLine.split(/\s{3,}/).filter(line => line.trim().length > 0);
                    // å¦‚æœè¿˜æ˜¯å¤ªé•¿ï¼Œå°è¯•æŒ‰ç‰¹å®šå…³é”®è¯åˆ†å‰²
                    if (firstPageLines.length === 1) {
                        const parts = longLine.split(/\s+(?:DOI|Received|Accepted|Published|Cite this|PAPER|View Article|State Key|College|Department)/i);
                        if (parts.length > 1) {
                            firstPageLines = parts.filter(line => line.trim().length > 0);
                        }
                    }
                    console.log('[ä½œè€…æå–] æ™ºèƒ½åˆ†å‰²åè¡Œæ•°:', firstPageLines.length);
                }
                
                console.log('[ä½œè€…æå–] ç¬¬ä¸€é¡µæ€»è¡Œæ•°:', firstPageLines.length);
                
                // æ”¹è¿›ï¼šä»åŸå§‹æ–‡æœ¬ä¸­ç›´æ¥æå–ä½œè€…ï¼ˆæ›´å¯é ï¼‰
                console.log('[ä½œè€…æå–] å°è¯•ä»åŸå§‹æ–‡æœ¬ç›´æ¥æå–ä½œè€…...');
                
                // æŸ¥æ‰¾ä½œè€…åŒºåŸŸï¼ˆé€šå¸¸åœ¨æ ‡é¢˜ä¹‹åï¼Œæœºæ„ä¿¡æ¯ä¹‹å‰ï¼‰
                // æŸ¥æ‰¾åŒ…å«å¤šä¸ªä½œè€…åçš„æ¨¡å¼ï¼ˆæ”¯æŒä¸Šä¸‹æ ‡æ ‡è®°ï¼‰
                // æ³¨æ„ï¼šmatchAlléœ€è¦å…¨å±€æ ‡å¿—
                const authorPattern = /([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?(?:\s*[a-z\s,]*\s*[A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?){1,}(?:\s+and\s+[A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)?)/g;
                
                // åœ¨åŸå§‹æ–‡æœ¬ä¸­æŸ¥æ‰¾ï¼ˆè·³è¿‡å‰é¢çš„æ ‡é¢˜éƒ¨åˆ†ï¼‰
                const titleEndIndex = firstPageText.indexOf('DOI:') > 0 ? firstPageText.indexOf('DOI:') : 
                                     (firstPageText.indexOf('Received') > 0 ? firstPageText.indexOf('Received') : firstPageText.length);
                const searchText = firstPageText.substring(0, Math.min(titleEndIndex + 500, firstPageText.length));
                
                console.log('[ä½œè€…æå–] æœç´¢åŒºåŸŸé•¿åº¦:', searchText.length, 'å‰200å­—ç¬¦:', searchText.substring(0, 200));
                
                // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„ä½œè€…åŒ¹é…ï¼ˆä½¿ç”¨matchAllé¿å…æ— é™å¾ªç¯ï¼‰
                let bestMatch = null;
                let bestMatchLength = 0;
                
                try {
                    // ä½¿ç”¨matchAllè·å–æ‰€æœ‰åŒ¹é…ï¼ˆæ›´å®‰å…¨ï¼Œä¸ä¼šæ— é™å¾ªç¯ï¼‰
                    const matches = searchText.matchAll(authorPattern);
                    let matchCount = 0;
                    const maxMatches = 10; // é™åˆ¶æœ€å¤šæ£€æŸ¥10ä¸ªåŒ¹é…
                    
                    for (const match of matches) {
                        matchCount++;
                        if (matchCount > maxMatches) {
                            console.log('[ä½œè€…æå–] è¾¾åˆ°æœ€å¤§åŒ¹é…æ•°é™åˆ¶ï¼Œåœæ­¢æœç´¢');
                            break;
                        }
                        
                        const matchText = match[1];
                        console.log('[ä½œè€…æå–] æ‰¾åˆ°ä½œè€…åŒ¹é… #' + matchCount + 'ï¼Œä½ç½®:', match.index, 'é•¿åº¦:', matchText.length, 'å†…å®¹:', matchText.substring(0, 100));
                        
                        // é€‰æ‹©æœ€é•¿çš„åŒ¹é…ï¼ˆé€šå¸¸åŒ…å«æ›´å¤šä½œè€…ï¼‰
                        if (matchText.length > bestMatchLength && matchText.length > 30) {
                            bestMatch = matchText;
                            bestMatchLength = matchText.length;
                        }
                    }
                    
                    console.log('[ä½œè€…æå–] æ€»å…±æ‰¾åˆ°', matchCount, 'ä¸ªåŒ¹é…');
                } catch (e) {
                    console.warn('[ä½œè€…æå–] matchAllå¤±è´¥ï¼Œå°è¯•ä½¿ç”¨match:', e);
                    // å¤‡ç”¨æ–¹æ³•ï¼šä½¿ç”¨matchï¼ˆåªè·å–ç¬¬ä¸€ä¸ªåŒ¹é…ï¼‰
                    const match = searchText.match(authorPattern);
                    if (match) {
                        bestMatch = match[1];
                        console.log('[ä½œè€…æå–] ä½¿ç”¨matchæ‰¾åˆ°åŒ¹é…ï¼Œé•¿åº¦:', bestMatch.length);
                    }
                }
                
                if (bestMatch) {
                    console.log('[ä½œè€…æå–] é€‰æ‹©æœ€ä½³åŒ¹é…ï¼Œé•¿åº¦:', bestMatch.length, 'å†…å®¹:', bestMatch.substring(0, 150));
                    let authorLine = bestMatch;
                    
                    // æ”¹è¿›çš„æ¸…ç†é€»è¾‘ï¼šæ›´ç²¾ç¡®åœ°ç§»é™¤ä¸Šä¸‹æ ‡æ ‡è®°
                    // åŒ¹é…æ¨¡å¼ï¼šåå­—åçš„ "a,b,c" æˆ– "a, b, c" è¿™æ ·çš„æ ‡è®°
                    // ä½†ä¸åˆ é™¤åå­—æœ¬èº«
                    authorLine = authorLine.replace(/\s+([a-z]\s*,\s*[a-z](?:\s*,\s*[a-z])*)\s+/gi, ' ');
                    // ç§»é™¤å•ç‹¬çš„ä¸Šä¸‹æ ‡æ ‡è®°ï¼ˆå¦‚ "a,b,c" å‰åæœ‰ç©ºæ ¼ï¼‰
                    authorLine = authorLine.replace(/\s*\b[a-z](?:\s*,\s*[a-z])+\b\s*/gi, ' ');
                    // ç§»é™¤æ˜Ÿå·ï¼ˆé€šè®¯ä½œè€…æ ‡è®°ï¼‰
                    authorLine = authorLine.replace(/\s*\*\s*/g, ' ');
                    // è§„èŒƒåŒ–ç©ºæ ¼
                    authorLine = authorLine.replace(/\s+/g, ' ').trim();
                    console.log('[ä½œè€…æå–] æ¸…ç†å:', authorLine);
                    
                    // æå–æ‰€æœ‰ä½œè€…ï¼ˆæŒ‰ "and" æˆ–é€—å·åˆ†å‰²ï¼‰
                    let authors = [];
                    // å…ˆæŒ‰ "and" åˆ†å‰²
                    const parts = authorLine.split(/\s+and\s+/i);
                    for (const part of parts) {
                        // å†æŒ‰é€—å·åˆ†å‰²
                        const names = part.split(/\s*,\s*/).map(a => a.trim()).filter(a => a.length > 0);
                        authors.push(...names);
                    }
                    
                    // è¿‡æ»¤å’ŒéªŒè¯ä½œè€…å
                    authors = authors.map(a => a.trim()).filter(a => {
                        // å¿…é¡»æ˜¯è‡³å°‘ä¸¤ä¸ªå•è¯ï¼ˆå+å§“ï¼‰ï¼Œä¸”æ¯ä¸ªå•è¯é¦–å­—æ¯å¤§å†™
                        const words = a.split(/\s+/);
                        if (words.length < 2) return false;
                        // æ£€æŸ¥æ˜¯å¦åƒåå­—ï¼ˆæ¯ä¸ªå•è¯é¦–å­—æ¯å¤§å†™ï¼Œåé¢æ˜¯å°å†™ï¼‰
                        const isValidName = words.every(w => /^[A-Z][a-z]+$/.test(w));
                        // æ’é™¤æœºæ„å
                        const isInstitution = a.match(/^(State Key|College|Department|Laboratory|University|Institute|Center|Centre)/i);
                        return isValidName && !isInstitution && a.length > 5;
                    });
                    
                    console.log('[ä½œè€…æå–] æå–åˆ°çš„ä½œè€…åˆ—è¡¨:', authors);
                    
                    if (authors.length > 0) {
                        firstAuthor = authors[0];
                        allAuthors = authors;
                        author = authors.join(', ');
                        console.log('[ä½œè€…æå–] âœ“ æ‰¾åˆ°ä½œè€…ï¼Œç¬¬ä¸€ä½œè€…:', firstAuthor, 'æ‰€æœ‰ä½œè€…:', allAuthors);
                    }
                }
                
                // å¦‚æœä»åŸå§‹æ–‡æœ¬æå–å¤±è´¥ï¼Œå°è¯•å¤šè¡Œåˆå¹¶å¤„ç†
                if (!firstAuthor && firstPageLines.length > 1) {
                    console.log('[ä½œè€…æå–] å°è¯•å¤šè¡Œåˆå¹¶æå–...');
                    
                    // æ”¹è¿›ï¼šåˆå¹¶è¿ç»­çš„å¯èƒ½ä½œè€…è¡Œ
                    let authorLines = [];
                    let inAuthorSection = false;
                    
                    for (let i = 0; i < Math.min(25, firstPageLines.length); i++) {
                        const line = firstPageLines[i].trim();
                        console.log(`[ä½œè€…æå–] æ£€æŸ¥ç¬¬${i + 1}è¡Œï¼Œé•¿åº¦:${line.length}, å†…å®¹:`, line.substring(0, 100));
                        
                        // æ£€æŸ¥æ˜¯å¦æ˜¯ä½œè€…è¡Œï¼ˆåŒ…å«åå­—æ¨¡å¼ï¼‰
                        const hasAuthorName = /[A-Z][a-z]+\s+[A-Z][a-z]+/.test(line);
                        const isShortLine = line.length < 200;
                        const hasMarkers = /[a-z]\s*,\s*[a-z]|\*/.test(line); // åŒ…å«ä¸Šä¸‹æ ‡æ ‡è®°æˆ–*
                        const isInstitution = /\b(University|College|Institute|Department|Laboratory|State Key)\b/i.test(line);
                        
                        // å¦‚æœåŒ…å«ä½œè€…åä¸”ä¸æ˜¯æœºæ„ä¿¡æ¯ï¼Œå¯èƒ½æ˜¯ä½œè€…è¡Œ
                        if (hasAuthorName && !isInstitution && (isShortLine || hasMarkers)) {
                            authorLines.push(line);
                            inAuthorSection = true;
                            console.log(`[ä½œè€…æå–] ç¬¬${i + 1}è¡ŒåŠ å…¥ä½œè€…å€™é€‰`);
                        } else if (inAuthorSection) {
                            // å¦‚æœå·²ç»åœ¨ä½œè€…åŒºåŸŸï¼Œé‡åˆ°éä½œè€…è¡Œå°±åœæ­¢
                            if (isInstitution || line.length > 200) {
                                break;
                            }
                            // å¦‚æœä¸‹ä¸€è¡Œå¾ˆçŸ­ä¸”åŒ…å«åå­—ï¼Œç»§ç»­
                            if (hasAuthorName && isShortLine) {
                                authorLines.push(line);
                            } else {
                                break;
                            }
                        }
                    }
                    
                    // åˆå¹¶ä½œè€…è¡Œ
                    if (authorLines.length > 0) {
                        console.log('[ä½œè€…æå–] åˆå¹¶', authorLines.length, 'è¡Œä½œè€…ä¿¡æ¯');
                        let mergedAuthorLine = authorLines.join(' ');
                        console.log('[ä½œè€…æå–] åˆå¹¶åçš„åŸå§‹æ–‡æœ¬:', mergedAuthorLine.substring(0, 200));
                        
                        // æ¸…ç†ï¼šç§»é™¤ä¸Šä¸‹æ ‡æ ‡è®°
                        mergedAuthorLine = mergedAuthorLine.replace(/\s*[a-z]\s*,\s*[a-z]\s*(?:,\s*[a-z]\s*)*/gi, '');
                        mergedAuthorLine = mergedAuthorLine.replace(/\s*\*\s*/g, ' ');
                        mergedAuthorLine = mergedAuthorLine.replace(/\s+/g, ' ').trim();
                        console.log('[ä½œè€…æå–] æ¸…ç†å:', mergedAuthorLine);
                        
                        // æå–æ‰€æœ‰ä½œè€…
                        const authors = mergedAuthorLine.split(/\s+and\s+|\s*,\s*/).map(a => a.trim()).filter(a => {
                            return a.length > 5 && /^[A-Z][a-z]+(\s+[A-Z][a-z]+)+/.test(a) && 
                                   !a.match(/^(State Key|College|Department|Laboratory|University|Institute|Electrochemical|ammonia|synthesis)/i);
                        });
                        
                        console.log('[ä½œè€…æå–] æå–åˆ°çš„ä½œè€…åˆ—è¡¨:', authors);
                        
                        if (authors.length > 0) {
                            firstAuthor = authors[0];
                            allAuthors = authors;
                            author = authors.join(', ');
                            console.log('[ä½œè€…æå–] âœ“ åˆå¹¶å¤šè¡Œæ‰¾åˆ°ä½œè€…ï¼Œç¬¬ä¸€ä½œè€…:', firstAuthor, 'æ‰€æœ‰ä½œè€…:', allAuthors);
                        }
                    }
                    
                    // å¦‚æœåˆå¹¶å¤šè¡Œè¿˜æ˜¯å¤±è´¥ï¼Œå°è¯•å•è¡ŒåŒ¹é…
                    if (!firstAuthor) {
                        console.log('[ä½œè€…æå–] å°è¯•å•è¡ŒåŒ¹é…...');
                        for (let i = 0; i < Math.min(20, firstPageLines.length); i++) {
                            const line = firstPageLines[i].trim();
                            
                            // æ”¹è¿›ï¼šæ›´å®½æ¾çš„ä½œè€…è¡ŒåŒ¹é…æ¨¡å¼
                            const authorLinePattern = /^([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?(?:\s*[a-z\s,]*\s*[A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)*(?:\s+and\s+[A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)?)/;
                            const authorMatch = line.match(authorLinePattern);
                            
                            if (authorMatch) {
                                console.log(`[ä½œè€…æå–] ç¬¬${i + 1}è¡ŒåŒ¹é…åˆ°ä½œè€…æ¨¡å¼ï¼ŒåŸå§‹åŒ¹é…:`, authorMatch[1].substring(0, 100));
                                
                                // æ¸…ç†ä½œè€…è¡Œï¼šç§»é™¤ä¸Šä¸‹æ ‡æ ‡è®°ï¼ˆå¦‚a,b,cï¼‰ã€ç‰¹æ®Šå­—ç¬¦ï¼ˆå¦‚*ï¼‰ç­‰
                                let authorLine = authorMatch[1];
                                console.log('[ä½œè€…æå–] æ¸…ç†å‰:', authorLine.substring(0, 100));
                                
                                // ç§»é™¤ä¸Šä¸‹æ ‡æ ‡è®°ï¼ˆå­—æ¯+é€—å·+ç©ºæ ¼ï¼Œå¦‚ " a , b , c " æˆ– "a,b,c"ï¼‰
                                authorLine = authorLine.replace(/\s*[a-z]\s*,\s*[a-z]\s*(?:,\s*[a-z]\s*)*/gi, '');
                                // ç§»é™¤å•ç‹¬çš„æ ‡è®°å­—ç¬¦ï¼ˆå¦‚ *ï¼‰
                                authorLine = authorLine.replace(/\s*\*\s*/g, ' ');
                                // ç§»é™¤å¤šä½™ç©ºç™½
                                authorLine = authorLine.replace(/\s+/g, ' ').trim();
                                
                                console.log('[ä½œè€…æå–] æ¸…ç†å:', authorLine);
                                
                                // æå–æ‰€æœ‰ä½œè€…ï¼ˆæ”¯æŒé€—å·å’Œ"and"åˆ†éš”ï¼‰
                                const authors = authorLine.split(/\s+and\s+|\s*,\s*/).map(a => a.trim()).filter(a => {
                                    // è¿‡æ»¤æ‰å¤ªçŸ­æˆ–çœ‹èµ·æ¥ä¸åƒåå­—çš„ç‰‡æ®µ
                                    return a.length > 3 && /^[A-Z][a-z]+(\s+[A-Z][a-z]+)+/.test(a);
                                });
                                
                                console.log('[ä½œè€…æå–] æå–åˆ°çš„ä½œè€…åˆ—è¡¨:', authors);
                                
                                if (authors.length > 0) {
                                    firstAuthor = authors[0];
                                    allAuthors = authors;
                                    author = authors.join(', ');
                                    console.log('[ä½œè€…æå–] âœ“ æ‰¾åˆ°ä½œè€…ï¼Œç¬¬ä¸€ä½œè€…:', firstAuthor, 'æ‰€æœ‰ä½œè€…:', allAuthors);
                                    break;
                                }
                            } else {
                                // å°è¯•æ›´ç®€å•çš„æ¨¡å¼ï¼šæŸ¥æ‰¾åŒ…å«å¤šä¸ªå¤§å†™å­—æ¯å¼€å¤´çš„å•è¯çš„è¡Œ
                                const simpleAuthorPattern = /([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?(?:\s*[,\s]*[a-z\s,]*\s*[A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)+)/;
                                const simpleMatch = line.match(simpleAuthorPattern);
                                if (simpleMatch && line.length < 200 && line.length > 30) {
                                    console.log(`[ä½œè€…æå–] ç¬¬${i + 1}è¡ŒåŒ¹é…åˆ°ç®€å•ä½œè€…æ¨¡å¼:`, simpleMatch[1].substring(0, 100));
                                    let authorLine = simpleMatch[1];
                                    authorLine = authorLine.replace(/\s*[a-z]\s*,\s*[a-z]\s*(?:,\s*[a-z]\s*)*/gi, '');
                                    authorLine = authorLine.replace(/\s*\*\s*/g, ' ');
                                    authorLine = authorLine.replace(/\s+/g, ' ').trim();
                                    const authors = authorLine.split(/\s+and\s+|\s*,\s*/).map(a => a.trim()).filter(a => a.length > 3);
                                    if (authors.length > 0) {
                                        firstAuthor = authors[0];
                                        allAuthors = authors;
                                        author = authors.join(', ');
                                        console.log('[ä½œè€…æå–] âœ“ æ‰¾åˆ°ä½œè€…ï¼ˆç®€å•æ¨¡å¼ï¼‰ï¼Œç¬¬ä¸€ä½œè€…:', firstAuthor);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // å¦‚æœè¿˜æ²¡æ‰¾åˆ°ï¼Œå°è¯•å…¶ä»–æ¨¡å¼
                if (!firstAuthor) {
                    console.log('[ä½œè€…æå–] å°è¯•å¤‡ç”¨æ–¹æ³•...');
                    const authorPatterns = [
                        /Author[s]?:\s*([^\n]+)/i,
                        /By:\s*([^\n]+)/i,
                        /^([A-Z][a-z]+\s+[A-Z]\.?\s+[A-Z][a-z]+)/m
                    ];
                    for (let pIndex = 0; pIndex < authorPatterns.length; pIndex++) {
                        const pattern = authorPatterns[pIndex];
                        const match = fullText.match(pattern);
                        if (match) {
                            console.log(`[ä½œè€…æå–] å¤‡ç”¨æ–¹æ³•${pIndex + 1}åŒ¹é…æˆåŠŸ:`, match[1].substring(0, 100));
                            let authorText = match[1].trim();
                            // æ¸…ç†ä½œè€…æ–‡æœ¬
                            authorText = authorText.replace(/\b[a-z](?:,[a-z])+\b/gi, '').replace(/\s*\*\s*/g, ' ').replace(/\s+/g, ' ').trim();
                            firstAuthor = authorText.split(/[,;]/)[0]?.trim() || authorText;
                            allAuthors = authorText.split(/[,;]/).map(a => a.trim());
                            console.log('[ä½œè€…æå–] âœ“ æ‰¾åˆ°ä½œè€…ï¼ˆå¤‡ç”¨æ–¹æ³•ï¼‰ï¼Œç¬¬ä¸€ä½œè€…:', firstAuthor);
                            break;
                        }
                    }
                }
                
                if (!firstAuthor) {
                    console.warn('[ä½œè€…æå–] âœ— æœªèƒ½ä»æ–‡æœ¬æå–åˆ°ä½œè€…');
                }
            } else if (firstAuthor && allAuthors.length === 0) {
                // å¦‚æœä»å…ƒæ•°æ®æå–åˆ°äº†ä½œè€…ï¼Œä¹Ÿå¡«å……allAuthors
                allAuthors = author.split(/[,;]/).map(a => a.trim());
                console.log('[ä½œè€…æå–] ä½¿ç”¨å…ƒæ•°æ®ä½œè€…ï¼Œæ‰€æœ‰ä½œè€…:', allAuthors);
            }

            // æå–æ—¥æœŸä¿¡æ¯
            const dates = extractDates(fullText, info);
            
            // æ ‡å‡†åŒ–æ‰€æœ‰æ—¥æœŸ
            if (dates.received) {
                dates.receivedNormalized = normalizeDateString(dates.received);
            }
            if (dates.revised) {
                dates.revisedNormalized = normalizeDateString(dates.revised);
            }
            if (dates.accepted) {
                dates.acceptedNormalized = normalizeDateString(dates.accepted);
            }
            if (dates.published) {
                dates.publishedNormalized = normalizeDateString(dates.published);
            }
            if (dates.availableOnline) {
                dates.availableOnlineNormalized = normalizeDateString(dates.availableOnline);
            }

            // æå–å…³é”®è¯
            const keywords = info.Keywords ? info.Keywords.split(/[,;]/).map(k => k.trim()) : [];

            // è¿‡æ»¤Subjectä¸­çš„æœŸåˆŠä¿¡æ¯ï¼ˆå¦‚"Engineering Failure Analysis, 173 (2025) 109456. doi:10.1016/j.engfailanal.2025.109456"ï¼‰
            let subject = info.Subject || '';
            // æ£€æŸ¥æ˜¯å¦åŒ…å«æœŸåˆŠä¿¡æ¯æ¨¡å¼ï¼ˆdoiã€å·å·ã€å¹´ä»½ç­‰ï¼‰
            const journalPattern = /(doi:|doi\.org|vol\.|volume|\(\d{4}\)|\d{4}\s*,\s*\d+|issn|isbn)/i;
            if (journalPattern.test(subject)) {
                console.log('æ£€æµ‹åˆ°SubjectåŒ…å«æœŸåˆŠä¿¡æ¯ï¼Œå·²è¿‡æ»¤:', subject);
                subject = ''; // æ¸…ç©ºæœŸåˆŠä¿¡æ¯
            }

            // æ£€æŸ¥æå–è´¨é‡ï¼šæ ‡é¢˜ã€ä½œè€…ã€æ—¥æœŸï¼ˆè‡³å°‘æœ‰ä¸€ä¸ªæ—¥æœŸï¼‰
            const hasTitle = title && title !== 'æœªæå–' && !title.match(/^[A-Z0-9]+[\s\d\.\+\-]+$/); // æ’é™¤åƒ"D5NR03036F 1..11 ++"è¿™æ ·çš„æ— æ•ˆæ ‡é¢˜
            const hasAuthor = firstAuthor && firstAuthor !== 'æœªæå–';
            const hasDate = dates.received || dates.accepted || dates.published || dates.availableOnline;
            
            const missingCount = (!hasTitle ? 1 : 0) + (!hasAuthor ? 1 : 0) + (!hasDate ? 1 : 0);
            console.log('æå–è´¨é‡æ£€æŸ¥:', {
                hasTitle, hasAuthor, hasDate, missingCount,
                title: title.substring(0, 50),
                firstAuthor: firstAuthor.substring(0, 30)
            });

            let ocrResult = null;
            // å¦‚æœè‡³å°‘ä¸¤ä¸ªä¿¡æ¯ç¼ºå¤±ï¼Œä½¿ç”¨OCRé‡æ–°è¯†åˆ«
            if (missingCount >= 2) {
                console.log('æ£€æµ‹åˆ°æå–ä¿¡æ¯ä¸å®Œæ•´ï¼ˆç¼ºå¤±' + missingCount + 'é¡¹ï¼‰ï¼Œå°è¯•ä½¿ç”¨OCRé‡æ–°è¯†åˆ«...');
                try {
                    ocrResult = await performOcrOnPdfFirstPage(pdf, arrayBuffer);
                    console.log('OCRè¯†åˆ«å®Œæˆï¼ŒåŸå§‹è¾“å‡º:', ocrResult);
                    
                    // åˆå¹¶OCRç»“æœ
                    if (ocrResult && ocrResult.structured) {
                        const ocr = ocrResult.structured;
                        
                        // å¦‚æœOCRæå–åˆ°äº†æ›´å¥½çš„æ ‡é¢˜ï¼Œä½¿ç”¨OCRçš„æ ‡é¢˜
                        if (!hasTitle && ocr.title && ocr.title !== 'Not mentioned') {
                            title = ocr.title;
                            console.log('ä½¿ç”¨OCRæå–çš„æ ‡é¢˜:', title);
                        }
                        
                        // å¦‚æœOCRæå–åˆ°äº†ä½œè€…ï¼Œä½¿ç”¨OCRçš„ä½œè€…
                        if (!hasAuthor && ocr.authors && ocr.authors !== 'Not mentioned') {
                            const ocrAuthors = ocr.authors.split(/[,;]/).map(a => a.trim()).filter(a => a.length > 0);
                            if (ocrAuthors.length > 0) {
                                firstAuthor = ocrAuthors[0];
                                allAuthors = ocrAuthors;
                                author = ocr.authors;
                                console.log('ä½¿ç”¨OCRæå–çš„ä½œè€…:', firstAuthor, 'æ‰€æœ‰ä½œè€…:', allAuthors);
                            }
                        }
                        
                        // å¦‚æœOCRæå–åˆ°äº†æ—¥æœŸï¼Œè¡¥å……ç¼ºå¤±çš„æ—¥æœŸ
                        if (ocr.dates) {
                            if (!dates.received && ocr.dates.received && ocr.dates.received !== 'Not mentioned') {
                                dates.received = ocr.dates.received;
                                dates.receivedNormalized = normalizeDateString(dates.received);
                                console.log('ä½¿ç”¨OCRæå–çš„Receivedæ—¥æœŸ:', dates.received);
                            }
                            if (!dates.revised && ocr.dates.revised && ocr.dates.revised !== 'Not mentioned') {
                                dates.revised = ocr.dates.revised;
                                dates.revisedNormalized = normalizeDateString(dates.revised);
                                console.log('ä½¿ç”¨OCRæå–çš„Revisedæ—¥æœŸ:', dates.revised);
                            }
                            if (!dates.accepted && ocr.dates.accepted && ocr.dates.accepted !== 'Not mentioned') {
                                dates.accepted = ocr.dates.accepted;
                                dates.acceptedNormalized = normalizeDateString(dates.accepted);
                                console.log('ä½¿ç”¨OCRæå–çš„Acceptedæ—¥æœŸ:', dates.accepted);
                            }
                            if (!dates.availableOnline && ocr.dates.available_online && ocr.dates.available_online !== 'Not mentioned') {
                                dates.availableOnline = ocr.dates.available_online;
                                dates.availableOnlineNormalized = normalizeDateString(dates.availableOnline);
                                console.log('ä½¿ç”¨OCRæå–çš„Available onlineæ—¥æœŸ:', dates.availableOnline);
                            }
                        }
                    }
                } catch (ocrError) {
                    console.warn('OCRè¯†åˆ«å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨PDFæå–ç»“æœ:', ocrError);
                }
            }

            return {
                success: true,
                fileName: file.name,
                fileSize: file.size,
                totalPages: pdf.numPages,
                isScanned: isScanned,
                usedOcr: ocrResult !== null,
                ocrResult: ocrResult,
                metadata: {
                    title: title || 'æœªæå–',
                    author: author || (allAuthors.length > 0 ? allAuthors.join(', ') : 'æœªæå–'),
                    firstAuthor: firstAuthor || 'æœªæå–',
                    allAuthors: allAuthors.length > 0 ? allAuthors : [],
                    subject: subject || 'æœªæå–',
                    keywords: keywords,
                    creator: info.Creator || 'æœªæå–',
                    producer: info.Producer || 'æœªæå–',
                    creationDate: info.CreationDate || 'æœªæå–',
                    modDate: info.ModDate || 'æœªæå–'
                },
                extractedDates: dates,
                textPreview: fullText.substring(0, 500),
                textLength: fullText.length
            };
        }

        // å¯¹PDFç¬¬ä¸€é¡µè¿›è¡ŒOCRè¯†åˆ«
        async function performOcrOnPdfFirstPage(pdf, arrayBuffer) {
            try {
                // è·å–OCRé…ç½®ï¼ˆä»localStorageæˆ–ä½¿ç”¨é»˜è®¤å€¼ï¼‰
                const savedConfig = localStorage.getItem('ocrConfig');
	                let ocrConfig = {
	                    baseUrl: 'https://api.tokenpony.cn/v1',
	                    apiKey: '',
	                    model: 'deepseek-ocr'
	                };
                if (savedConfig) {
                    ocrConfig = { ...ocrConfig, ...JSON.parse(savedConfig) };
                }

                if (!ocrConfig.apiKey) {
                    throw new Error('OCR API Keyæœªé…ç½®');
                }

                // å°†PDFç¬¬ä¸€é¡µè½¬æ¢ä¸ºå›¾ç‰‡
                const page = await pdf.getPage(1);
                const viewport = page.getViewport({ scale: 2 });
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                const context = canvas.getContext('2d');

                await page.render({
                    canvasContext: context,
                    viewport: viewport
                }).promise;

                // å°†canvasè½¬æ¢ä¸ºbase64
                const imageDataUrl = canvas.toDataURL('image/jpeg', 0.95);

                // æ”¹è¿›çš„OCRæç¤ºè¯ï¼ˆæ›´ç®€æ´æ˜ç¡®ï¼Œä¸åŒ…å«ç¤ºä¾‹é¿å…æ¨¡å‹é‡å¤ï¼‰
                const ocrPrompt = `åˆ†æè¿™å¼ å­¦æœ¯è®ºæ–‡å›¾ç‰‡ï¼Œæå–ä¿¡æ¯å¹¶è¾“å‡ºJSONæ ¼å¼ã€‚

æå–å­—æ®µï¼š
- document_type: æ–‡æ¡£ç±»å‹ï¼ˆè®ºæ–‡é¦–é¡µ/å½•ç”¨é€šçŸ¥/é‚®ä»¶/å…¶ä»–ï¼‰
- title: è®ºæ–‡æ ‡é¢˜ï¼ˆæ²¡æœ‰åˆ™å¡«"Not mentioned"ï¼‰
- authors: æ‰€æœ‰ä½œè€…ï¼Œé€—å·åˆ†éš”ï¼ˆæ²¡æœ‰åˆ™å¡«"Not mentioned"ï¼‰
- dates: æ—¥æœŸå¯¹è±¡
  * received: æŠ•ç¨¿æ—¥æœŸï¼ˆReceivedæ—¥æœŸï¼ŒYYYY-MM-DDæ ¼å¼ï¼‰
  * revised: ä¿®è®¢æ—¥æœŸï¼ˆRevisedæ—¥æœŸï¼ŒYYYY-MM-DDæ ¼å¼ï¼‰
  * accepted: å½•ç”¨æ—¥æœŸï¼ˆAcceptedæ—¥æœŸï¼ŒYYYY-MM-DDæ ¼å¼ï¼‰
  * available_online: åœ¨çº¿å‘è¡¨æ—¥æœŸï¼ˆAvailable onlineæ—¥æœŸï¼ŒYYYY-MM-DDæ ¼å¼ï¼‰
  ï¼ˆæ²¡æœ‰åˆ™å¡«"Not mentioned"ï¼‰
- confidence_note: ç½®ä¿¡åº¦è¯´æ˜ï¼ˆå¯é€‰ï¼‰

åªè¾“å‡ºJSONï¼Œä¸è¦ä»»ä½•è§£é‡Šæ–‡å­—ã€‚`;

                // å‘é€OCRè¯·æ±‚
                const apiUrl = `${ocrConfig.baseUrl}/chat/completions`;
                const requestBody = {
                    model: ocrConfig.model,
                    messages: [
                        {
                            role: 'user',
                            content: [
                                {
                                    type: 'text',
                                    text: ocrPrompt
                                },
                                {
                                    type: 'image_url',
                                    image_url: {
                                        url: imageDataUrl
                                    }
                                }
                            ]
                        }
                    ],
                    temperature: 0,
                    max_tokens: 4096,
                    stream: false
                };

                console.log('å‘é€OCRè¯·æ±‚ï¼ŒAPI URL:', apiUrl);
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${ocrConfig.apiKey}`
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`OCR APIè¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText} - ${errorText}`);
                }

                const data = await response.json();

                // æå–è¯†åˆ«ç»“æœ
                if (data.choices && data.choices.length > 0) {
                    const content = data.choices[0].message.content;
                    console.log('OCRåŸå§‹è¾“å‡ºï¼ˆå®Œæ•´ï¼‰:', content);
                    console.log('OCRåŸå§‹è¾“å‡ºé•¿åº¦:', content.length);
                    
                    // å°è¯•è§£æJSONæ ¼å¼çš„ç»“æœ
                    let jsonData = null;
                    let parseError = null;
                    try {
                        // å…ˆå°è¯•æå–ä»£ç å—ä¸­çš„JSON
                        const jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/);
                        if (jsonMatch) {
                            jsonData = JSON.parse(jsonMatch[1]);
                            console.log('[OCRè§£æ] ä»jsonä»£ç å—è§£ææˆåŠŸ');
                        } else {
                            // å°è¯•æå–ä»£ç å—ï¼ˆæ— è¯­è¨€æ ‡è®°ï¼‰
                            const codeMatch = content.match(/```\s*([\s\S]*?)\s*```/);
                            if (codeMatch) {
                                try {
                                    jsonData = JSON.parse(codeMatch[1]);
                                    console.log('[OCRè§£æ] ä»ä»£ç å—è§£ææˆåŠŸ');
                                } catch (e) {
                                    console.warn('[OCRè§£æ] ä»£ç å—è§£æå¤±è´¥:', e);
                                }
                            }
                            
                            // å¦‚æœä»£ç å—è§£æå¤±è´¥ï¼Œå°è¯•æå–JSONå¯¹è±¡ï¼ˆå¯èƒ½è¢«å…¶ä»–æ–‡å­—åŒ…å›´ï¼‰
                            if (!jsonData) {
                                // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„JSONå¯¹è±¡
                                const jsonMatches = content.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g);
                                if (jsonMatches && jsonMatches.length > 0) {
                                    // å°è¯•è§£ææ¯ä¸ªåŒ¹é…çš„JSON
                                    for (const jsonStr of jsonMatches) {
                                        try {
                                            const parsed = JSON.parse(jsonStr);
                                            // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„å­¦æœ¯æ–‡æ¡£JSONï¼ˆåŒ…å«document_typeæˆ–titleå­—æ®µï¼‰
                                            if (parsed.document_type || parsed.title || parsed.authors || parsed.dates) {
                                                jsonData = parsed;
                                                console.log('[OCRè§£æ] ä»æ–‡æœ¬ä¸­æå–JSONè§£ææˆåŠŸ');
                                                break;
                                            }
                                        } catch (e) {
                                            // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ª
                                        }
                                    }
                                }
                            }
                            
                            // å¦‚æœè¿˜æ˜¯æ²¡æ‰¾åˆ°ï¼Œå°è¯•ç›´æ¥è§£ææ•´ä¸ªå†…å®¹
                            if (!jsonData) {
                                try {
                                    jsonData = JSON.parse(content);
                                    console.log('[OCRè§£æ] ç›´æ¥è§£ææ•´ä¸ªå†…å®¹æˆåŠŸ');
                                } catch (e) {
                                    console.warn('[OCRè§£æ] æ‰€æœ‰è§£ææ–¹æ³•éƒ½å¤±è´¥');
                                    parseError = e.message;
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('[OCRè§£æ] JSONè§£æå¤±è´¥:', e);
                        console.warn('[OCRè§£æ] å°è¯•è§£æçš„å†…å®¹å‰500å­—ç¬¦:', content.substring(0, 500));
                        parseError = e.message;
                    }
                    
                    // å¦‚æœè§£ææˆåŠŸä½†å†…å®¹çœ‹èµ·æ¥åƒpromptæœ¬èº«ï¼Œæ ‡è®°ä¸ºæ— æ•ˆ
                    if (jsonData && (
                        jsonData.title === 'è®ºæ–‡æ ‡é¢˜' || 
                        jsonData.authors === 'ä½œè€…1, ä½œè€…2' ||
                        (jsonData.dates && jsonData.dates.received === '2025-01-01' && jsonData.dates.accepted === '2025-02-01')
                    )) {
                        console.warn('[OCRè§£æ] æ£€æµ‹åˆ°è§£æç»“æœæ˜¯ç¤ºä¾‹æ•°æ®ï¼Œå¯èƒ½æ˜¯æ¨¡å‹è¿”å›äº†prompt');
                        jsonData = null;
                        parseError = 'è§£æç»“æœæ˜¯ç¤ºä¾‹æ•°æ®ï¼Œéå®é™…è¯†åˆ«ç»“æœ';
                    }
                    
                    return {
                        rawText: content,
                        structured: jsonData,
                        isStructured: jsonData !== null,
                        parseError: parseError || (jsonData === null ? 'æ— æ³•è§£æJSONæ ¼å¼' : null)
                    };
                } else {
                    throw new Error('OCR APIè¿”å›ç»“æœä¸ºç©º');
                }
            } catch (error) {
                console.error('OCRè¯†åˆ«å¤±è´¥:', error);
                throw error;
            }
        }

        // æ ‡å‡†åŒ–æ—¥æœŸå­—ç¬¦ä¸²ä¸º YYYY-MM-DD æ ¼å¼
        function normalizeDateString(dateStr) {
            if (!dateStr) return '';
            
            // å¤„ç†ä¸­æ–‡æ—¥æœŸæ ¼å¼ï¼šYYYYå¹´MMæœˆDDæ—¥ æˆ– YYYYå¹´MMæœˆ
            const chineseDateMatch = dateStr.match(/(\d{4})\s*å¹´\s*(\d{1,2})\s*æœˆ(?:\s*(\d{1,2})\s*æ—¥?)?/);
            if (chineseDateMatch) {
                const year = chineseDateMatch[1];
                const month = String(chineseDateMatch[2]).padStart(2, '0');
                const day = chineseDateMatch[3] ? String(chineseDateMatch[3]).padStart(2, '0') : '15'; // å¦‚æœæ²¡æœ‰æ—¥æœŸï¼Œé»˜è®¤15å·
                return `${year}-${month}-${day}`;
            }
            
            // å¦‚æœå·²ç»æ˜¯YYYY-MM-DDæ ¼å¼
            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                return dateStr;
            }
            
            // å¤„ç† "Month DD, YYYY" æ ¼å¼ (å¦‚: "August 9, 2025")
            const monthDayYearMatch = dateStr.match(/([A-Z][a-z]+)\s+(\d{1,2}),?\s+(\d{4})/);
            if (monthDayYearMatch) {
                const monthNames = {
                    'January': '01', 'February': '02', 'March': '03', 'April': '04',
                    'May': '05', 'June': '06', 'July': '07', 'August': '08',
                    'September': '09', 'October': '10', 'November': '11', 'December': '12'
                };
                const month = monthNames[monthDayYearMatch[1]];
                if (month) {
                    const day = monthDayYearMatch[2].padStart(2, '0');
                    const year = monthDayYearMatch[3];
                    return `${year}-${month}-${day}`;
                }
            }
            
            // å¤„ç† "DD(st/nd/rd/th) Month YYYY" æ ¼å¼ (å¦‚: "18th July 2025", "13 June 2025" æˆ– "9 August 2025")
            const dayMonthYearMatch = dateStr.match(/(\d{1,2})(?:st|nd|rd|th)?\s+([A-Z][a-z]+)\s+(\d{4})/);
            if (dayMonthYearMatch) {
                const monthNames = {
                    'January': '01', 'February': '02', 'March': '03', 'April': '04',
                    'May': '05', 'June': '06', 'July': '07', 'August': '08',
                    'September': '09', 'October': '10', 'November': '11', 'December': '12'
                };
                const month = monthNames[dayMonthYearMatch[2]];
                if (month) {
                    const day = dayMonthYearMatch[1].padStart(2, '0');
                    const year = dayMonthYearMatch[3];
                    return `${year}-${month}-${day}`;
                }
            }
            
            // å¤„ç† "Month DD(st/nd/rd/th), YYYY" æ ¼å¼ (å¦‚: "July 18th, 2025")
            const monthDayYearWithOrdinalMatch = dateStr.match(/([A-Z][a-z]+)\s+(\d{1,2})(?:st|nd|rd|th)?,?\s+(\d{4})/);
            if (monthDayYearWithOrdinalMatch) {
                const monthNames = {
                    'January': '01', 'February': '02', 'March': '03', 'April': '04',
                    'May': '05', 'June': '06', 'July': '07', 'August': '08',
                    'September': '09', 'October': '10', 'November': '11', 'December': '12'
                };
                const month = monthNames[monthDayYearWithOrdinalMatch[1]];
                if (month) {
                    const day = monthDayYearWithOrdinalMatch[2].padStart(2, '0');
                    const year = monthDayYearWithOrdinalMatch[3];
                    return `${year}-${month}-${day}`;
                }
            }
            
            // å¤„ç† YYYY-MM-DD æˆ– YYYY/MM/DD æ ¼å¼
            const ymdMatch = dateStr.match(/(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})/);
            if (ymdMatch) {
                const year = ymdMatch[1];
                const month = ymdMatch[2].padStart(2, '0');
                const day = ymdMatch[3].padStart(2, '0');
                return `${year}-${month}-${day}`;
            }
            
            // å¦‚æœæ— æ³•è§£æï¼Œè¿”å›åŸå­—ç¬¦ä¸²
            return dateStr;
        }

        // æå–æ—¥æœŸä¿¡æ¯ï¼ˆæ”¹è¿›ç‰ˆï¼Œæ”¯æŒæ›´ç²¾ç¡®çš„æ—¥æœŸæ ¼å¼ï¼‰
        function extractDates(text, info) {
            const dates = {
                received: null,
                revised: null,
                accepted: null,
                published: null,
                availableOnline: null,
                other: []
            };

            // æ—¥æœŸå…³é”®è¯ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼Œé•¿çš„åœ¨å‰ï¼‰
            const dateKeywords = {
                revised: [
                    'Received in revised form',
                    'in revised form',
                    'revised form',
                    'Revised',
                    'Revised:'
                ],
                received: [
                    'Received',
                    'Received date',
                    'Received:',
                    'Submitted',
                    'Submitted on',
                    'Submission date'
                ],
                accepted: [
                    'Accepted',
                    'Accepted date',
                    'Accepted:',
                    'Acceptance date'
                ],
                availableOnline: [
                    'Available online',
                    'Available online:',
                    'Available Online',
                    'Available Online:',
                    'available online',
                    'available online:',
                    'Published online',
                    'Published online:',
                    'Online available',
                    'Online available:'
                ],
                published: [
                    'Published',
                    'Published date',
                    'Published:',
                    'Publication date',
                    'Date of publication'
                ]
            };

            // æ—¥æœŸæ ¼å¼ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼Œæ›´å…·ä½“çš„æ ¼å¼ä¼˜å…ˆï¼‰
            // æ³¨æ„ï¼šæ”¯æŒåºæ•°åç¼€ï¼ˆst, nd, rd, thï¼‰
            const datePatterns = [
                /(\d{1,2}(?:st|nd|rd|th)?\s+[A-Z][a-z]+\s+\d{4})/,    // DD(st/nd/rd/th) Month YYYY (å¦‚: 18th July 2025, 1st January 2025)
                /(\d{1,2}\s+[A-Z][a-z]+\s+\d{4})/,                    // DD Month YYYY (å¦‚: 1 January 2025)
                /([A-Z][a-z]+\s+\d{1,2}(?:st|nd|rd|th)?,?\s+\d{4})/,  // Month DD(st/nd/rd/th), YYYY (å¦‚: July 18th, 2025)
                /([A-Z][a-z]+\s+\d{1,2},\s+\d{4})/,                   // Month DD, YYYY (å¦‚: January 1, 2025)
                /(\d{4}[-/]\d{1,2}[-/]\d{1,2})/,                      // YYYY-MM-DD
                /(\d{1,2}[-/]\d{1,2}[-/]\d{4})/,                      // MM-DD-YYYY
                /(\d{4})/                                              // YYYY
            ];

            // å…ˆæå–Revisedæ—¥æœŸï¼ˆå¿…é¡»åœ¨Receivedä¹‹å‰ï¼Œå› ä¸º"Received in revised form"åŒ…å«"Received"ï¼‰
            for (const keyword of dateKeywords.revised) {
                const keywordRegex = new RegExp(keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                const keywordMatch = text.match(keywordRegex);
                if (keywordMatch) {
                    const keywordIndex = keywordMatch.index;
                    const context = text.substring(keywordIndex, keywordIndex + 200).replace(/\s+/g, ' ');
                    console.log('æ£€æŸ¥Revisedæ—¥æœŸï¼Œå…³é”®è¯:', keyword, 'ä¸Šä¸‹æ–‡:', context.substring(0, 100));
                    for (const pattern of datePatterns) {
                        const match = context.match(pattern);
                        if (match) {
                            dates.revised = match[1];
                            console.log('æ‰¾åˆ°Revisedæ—¥æœŸ:', match[1]);
                            break;
                        }
                    }
                    if (dates.revised) break;
                }
            }

            // æå–Receivedæ—¥æœŸï¼ˆæ’é™¤å·²ç»è¢«RevisedåŒ¹é…çš„éƒ¨åˆ†ï¼‰
            for (const keyword of dateKeywords.received) {
                const keywordRegex = new RegExp(keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                let match;
                while ((match = keywordRegex.exec(text)) !== null) {
                    const keywordIndex = match.index;
                    // æ£€æŸ¥è¿™ä¸ªä½ç½®æ˜¯å¦å±äº"Received in revised form"ï¼ˆå¦‚æœæ˜¯ï¼Œè·³è¿‡ï¼‰
                    const checkRevised = text.substring(keywordIndex, keywordIndex + 30).toLowerCase();
                    if (checkRevised.includes('received in revised form') || checkRevised.includes('in revised form')) {
                        continue; // è·³è¿‡ï¼Œå› ä¸ºè¿™æ˜¯Revisedæ—¥æœŸçš„ä¸€éƒ¨åˆ†
                    }
                    
                    const context = text.substring(keywordIndex, keywordIndex + 200).replace(/\s+/g, ' ');
                    console.log('æ£€æŸ¥Receivedæ—¥æœŸï¼Œå…³é”®è¯:', keyword, 'ä¸Šä¸‹æ–‡:', context.substring(0, 100));
                    for (const pattern of datePatterns) {
                        const dateMatch = context.match(pattern);
                        if (dateMatch) {
                            dates.received = dateMatch[1];
                            console.log('æ‰¾åˆ°Receivedæ—¥æœŸ:', dateMatch[1]);
                            break;
                        }
                    }
                    if (dates.received) break;
                }
                if (dates.received) break;
            }

            // æå–Acceptedæ—¥æœŸ
            for (const keyword of dateKeywords.accepted) {
                const keywordRegex = new RegExp(keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                const keywordMatch = text.match(keywordRegex);
                if (keywordMatch) {
                    const keywordIndex = keywordMatch.index;
                    const context = text.substring(keywordIndex, keywordIndex + 200).replace(/\s+/g, ' ');
                    console.log('æ£€æŸ¥Acceptedæ—¥æœŸï¼Œå…³é”®è¯:', keyword, 'ä¸Šä¸‹æ–‡:', context.substring(0, 100));
                    for (const pattern of datePatterns) {
                        const match = context.match(pattern);
                        if (match) {
                            dates.accepted = match[1];
                            console.log('æ‰¾åˆ°Acceptedæ—¥æœŸ:', match[1]);
                            break;
                        }
                    }
                    if (dates.accepted) break;
                }
            }

            // æå–Available onlineæ—¥æœŸï¼ˆä¼˜å…ˆï¼‰
            for (const keyword of dateKeywords.availableOnline) {
                // ä½¿ç”¨æ›´å®½æ¾çš„åŒ¹é…ï¼Œå…è®¸å…³é”®è¯å‰åæœ‰ç©ºæ ¼ã€æ¢è¡Œç­‰
                const keywordRegex = new RegExp('\\b' + keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/\s+/g, '\\s+') + '\\b', 'i');
                const keywordMatch = text.match(keywordRegex);
                if (keywordMatch) {
                    const keywordIndex = keywordMatch.index;
                    const keywordLength = keywordMatch[0].length;
                    // å¢åŠ ä¸Šä¸‹æ–‡é•¿åº¦åˆ°300å­—ç¬¦ï¼Œä»¥ä¾¿æ‰¾åˆ°æ›´è¿œçš„æ—¥æœŸ
                    const context = text.substring(keywordIndex, keywordIndex + 300);
                    console.log('æ£€æŸ¥Available onlineæ—¥æœŸï¼Œå…³é”®è¯:', keyword, 'åŒ¹é…ä½ç½®:', keywordIndex, 'ä¸Šä¸‹æ–‡:', context.substring(0, 150));
                    
                    // åœ¨"Available online"ä¹‹åç›´æ¥æŸ¥æ‰¾æ—¥æœŸï¼ˆä¸è§„èŒƒåŒ–ç©ºæ ¼ï¼Œä¿æŒåŸå§‹æ ¼å¼ï¼‰
                    // æŸ¥æ‰¾"Available online"ä¹‹åçš„ä¸‹ä¸€ä¸ªæ—¥æœŸæ¨¡å¼
                    let foundDate = false;
                    for (const pattern of datePatterns) {
                        // åœ¨ä¸Šä¸‹æ–‡ä¸­æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…çš„æ—¥æœŸï¼ˆä½¿ç”¨åŸå§‹æ–‡æœ¬ï¼Œä¸è§„èŒƒåŒ–ç©ºæ ¼ï¼‰
                        const matches = context.matchAll(new RegExp(pattern.source, 'g'));
                        for (const match of matches) {
                            const dateStr = match[1];
                            const dateIndex = match.index;
                            // ç¡®ä¿æ—¥æœŸåœ¨"Available online"ä¹‹åï¼ˆè‡³å°‘è·³è¿‡å…³é”®è¯æœ¬èº«ï¼‰
                            if (dateIndex >= keywordLength) {
                                // æ£€æŸ¥æ—¥æœŸæ˜¯å¦ç´§è·Ÿåœ¨"Available online"ä¹‹åï¼ˆåœ¨80ä¸ªå­—ç¬¦å†…ï¼Œå› ä¸ºå¯èƒ½æœ‰æœŸåˆŠä¿¡æ¯ï¼‰
                                const distanceFromKeyword = dateIndex - keywordLength;
                                if (distanceFromKeyword <= 80) {
                                    // æ£€æŸ¥æ—¥æœŸå‰æ˜¯å¦æœ‰æœŸåˆŠä¿¡æ¯
                                    const beforeDate = context.substring(keywordLength, dateIndex);
                                    const hasJournalInfo = /(Computers|Electronics|Agriculture|Journal|Volume|Vol\.|\(\d{4}\)|doi|\d{6})/i.test(beforeDate);
                                    
                                    // å¦‚æœæ—¥æœŸå‰æœ‰æœŸåˆŠä¿¡æ¯ï¼Œä½†è·ç¦»å…³é”®è¯è¾ƒè¿‘ï¼ˆ<50å­—ç¬¦ï¼‰ï¼Œå¯èƒ½æ˜¯Available onlineçš„æ—¥æœŸ
                                    // å¦‚æœæ—¥æœŸå‰æ²¡æœ‰æœŸåˆŠä¿¡æ¯ï¼Œç›´æ¥ä½¿ç”¨
                                    if (!hasJournalInfo || distanceFromKeyword < 50) {
                                        dates.availableOnline = dateStr;
                                        console.log('æ‰¾åˆ°Available onlineæ—¥æœŸ:', dateStr, 'è·ç¦»å…³é”®è¯:', distanceFromKeyword, 'å­—ç¬¦, å‰æ–‡:', beforeDate.substring(0, 50));
                                        foundDate = true;
                                        break;
                                    } else {
                                        console.log('è·³è¿‡æ—¥æœŸï¼ˆæœŸåˆŠä¿¡æ¯å¹²æ‰°ï¼‰:', dateStr, 'è·ç¦»:', distanceFromKeyword, 'å‰æ–‡:', beforeDate.substring(0, 50));
                                    }
                                }
                            }
                        }
                        if (foundDate) break;
                    }
                    
                    // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå°è¯•æ›´å®½æ¾çš„åŒ¹é…ï¼ˆåœ¨"Available online"ä¹‹åæŸ¥æ‰¾ä»»ä½•æ—¥æœŸï¼‰
                    if (!foundDate) {
                        // ä»"Available online"ä¹‹åå¼€å§‹æœç´¢ï¼ˆä¸è·³è¿‡å¤ªå¤šå­—ç¬¦ï¼Œå› ä¸ºæ—¥æœŸå¯èƒ½å°±åœ¨åé¢ï¼‰
                        const searchStart = keywordIndex + keywordLength;
                        const searchText = text.substring(searchStart, searchStart + 100); // åªæœç´¢100å­—ç¬¦ï¼Œå› ä¸ºæ—¥æœŸé€šå¸¸å°±åœ¨åé¢
                        console.log('Available onlineåæœç´¢åŒºåŸŸï¼ˆå®½æ¾åŒ¹é…ï¼‰:', searchText.substring(0, 100));
                        for (const pattern of datePatterns) {
                            const match = searchText.match(pattern);
                        if (match) {
                            dates.availableOnline = match[1];
                                console.log('æ‰¾åˆ°Available onlineæ—¥æœŸï¼ˆå®½æ¾åŒ¹é…ï¼‰:', match[1]);
                                foundDate = true;
                            break;
                        }
                    }
                    }
                    
                    if (foundDate) break;
                } else {
                    // è°ƒè¯•ï¼šå¦‚æœæ²¡åŒ¹é…åˆ°ï¼Œè¾“å‡ºå¯èƒ½çš„åŒ¹é…ä½ç½®
                    const simpleMatch = text.match(/available\s+online/i);
                    if (simpleMatch) {
                        console.log('æ‰¾åˆ°"available online"ï¼ˆä½†å…³é”®è¯åŒ¹é…å¤±è´¥ï¼‰ï¼Œä½ç½®:', simpleMatch.index, 'ä¸Šä¸‹æ–‡:', text.substring(simpleMatch.index, simpleMatch.index + 100));
                    }
                }
            }

            // æå–Publishedæ—¥æœŸï¼ˆå¦‚æœAvailable onlineæ²¡æ‰¾åˆ°ï¼‰
            if (!dates.availableOnline) {
                for (const keyword of dateKeywords.published) {
                    const keywordRegex = new RegExp(keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                    const keywordMatch = text.match(keywordRegex);
                    if (keywordMatch) {
                        const keywordIndex = keywordMatch.index;
                        const context = text.substring(keywordIndex, keywordIndex + 200).replace(/\s+/g, ' ');
                        console.log('æ£€æŸ¥Publishedæ—¥æœŸï¼Œå…³é”®è¯:', keyword, 'ä¸Šä¸‹æ–‡:', context.substring(0, 100));
                        for (const pattern of datePatterns) {
                            const match = context.match(pattern);
                            if (match) {
                                dates.published = match[1];
                                console.log('æ‰¾åˆ°Publishedæ—¥æœŸ:', match[1]);
                                break;
                            }
                        }
                        if (dates.published) break;
                    }
                }
            }

            // ä»å…ƒæ•°æ®æå–åˆ›å»ºæ—¥æœŸï¼ˆä»…ä½œä¸ºå‚è€ƒï¼Œä¸è¦†ç›–å·²æå–çš„æ—¥æœŸï¼‰
            if (info.CreationDate && !dates.received && !dates.accepted) {
                dates.other.push({ type: 'CreationDate', value: info.CreationDate });
            }
            if (info.ModDate && !dates.received && !dates.accepted) {
                dates.other.push({ type: 'ModDate', value: info.ModDate });
            }

            return dates;
        }

        // æ˜¾ç¤ºç»“æœ
        function displayResult(fileName, result, isLast) {
            const resultSection = document.createElement('div');
            resultSection.className = 'result-section';
            resultSection.innerHTML = `
                <h3>ğŸ“„ ${fileName}</h3>
                <div class="result-item">
                    <span class="result-label">æ–‡ä»¶å¤§å°:</span>
                    <span class="result-value">${(result.fileSize / 1024).toFixed(2)} KB</span>
                </div>
                <div class="result-item">
                    <span class="result-label">æ€»é¡µæ•°:</span>
                    <span class="result-value">${result.totalPages}</span>
                </div>
                <div class="result-item">
                    <span class="result-label">æ˜¯å¦æ‰«æä»¶:</span>
                    <span class="result-value">${result.isScanned ? 'æ˜¯ï¼ˆæ–‡æœ¬è¾ƒå°‘ï¼Œå¯èƒ½éœ€è¦OCRï¼‰' : 'å¦ï¼ˆåŒ…å«æ–‡æœ¬ï¼‰'}</span>
                </div>
                ${result.usedOcr ? `
                <div class="result-item" style="background: #d1ecf1; padding: 10px; border-radius: 4px; margin-top: 10px;">
                    <span class="result-label">OCRè¾…åŠ©:</span>
                    <span class="result-value" style="color: #0c5460; font-weight: bold;">âœ“ å·²ä½¿ç”¨OCRé‡æ–°è¯†åˆ«ä»¥è¡¥å……ç¼ºå¤±ä¿¡æ¯</span>
                </div>
                ${result.ocrResult ? `
                <div class="result-item" style="background: #fff3cd; padding: 15px; border-radius: 4px; margin-top: 10px;">
                    <h5 style="margin-top: 0; color: #856404;">ğŸ” OCRåŸå§‹è¾“å‡ºï¼ˆå®Œæ•´å›æ˜¾ï¼‰</h5>
                    <div style="margin-bottom: 10px;">
                        <strong>è¾“å‡ºé•¿åº¦:</strong> ${result.ocrResult.rawText ? result.ocrResult.rawText.length : 0} å­—ç¬¦
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>æ˜¯å¦ç»“æ„åŒ–:</strong> ${result.ocrResult.isStructured ? 'æ˜¯' : 'å¦'}
                        ${result.ocrResult.parseError ? ` <span style="color: #dc3545;">(${result.ocrResult.parseError})</span>` : ''}
                    </div>
                    <details style="margin-top: 10px;">
                        <summary style="cursor: pointer; color: #856404; font-weight: bold;">ç‚¹å‡»æŸ¥çœ‹å®Œæ•´åŸå§‹è¾“å‡º</summary>
                        <pre style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-top: 10px; max-height: 400px; overflow-y: auto; font-size: 11px; white-space: pre-wrap; word-wrap: break-word;">${result.ocrResult.rawText || 'æ— è¾“å‡º'}</pre>
                    </details>
                    ${result.ocrResult.structured ? `
                    <details style="margin-top: 10px;">
                        <summary style="cursor: pointer; color: #856404; font-weight: bold;">ç‚¹å‡»æŸ¥çœ‹è§£æåçš„ç»“æ„åŒ–æ•°æ®</summary>
                        <pre style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-top: 10px; max-height: 300px; overflow-y: auto; font-size: 11px;">${JSON.stringify(result.ocrResult.structured, null, 2)}</pre>
                    </details>
                    ` : ''}
                </div>
                ` : ''}
                ` : ''}
                <div class="result-item">
                    <span class="result-label">æå–çš„æ–‡æœ¬é•¿åº¦:</span>
                    <span class="result-value">${result.textLength} å­—ç¬¦</span>
                </div>
                <h4>å…ƒæ•°æ®ä¿¡æ¯</h4>
                <div class="result-item">
                    <span class="result-label">æ ‡é¢˜:</span>
                    <span class="result-value">${result.metadata.title}</span>
                </div>
                <div class="result-item">
                    <span class="result-label">ä½œè€…:</span>
                    <span class="result-value">${result.metadata.author}</span>
                </div>
                <div class="result-item">
                    <span class="result-label">ç¬¬ä¸€ä½œè€…:</span>
                    <span class="result-value">${result.metadata.firstAuthor}</span>
                </div>
                ${result.metadata.allAuthors && result.metadata.allAuthors.length > 1 ? `
                <div class="result-item">
                    <span class="result-label">æ‰€æœ‰ä½œè€…:</span>
                    <span class="result-value">${result.metadata.allAuthors.join(', ')}</span>
                </div>
                ` : ''}
                <div class="result-item">
                    <span class="result-label">ä¸»é¢˜:</span>
                    <span class="result-value">${result.metadata.subject}</span>
                </div>
                <div class="result-item">
                    <span class="result-label">å…³é”®è¯:</span>
                    <span class="result-value">${result.metadata.keywords.length > 0 ? result.metadata.keywords.join(', ') : 'æ— '}</span>
                </div>
                <div class="result-item">
                    <span class="result-label">åˆ›å»ºæ—¥æœŸ:</span>
                    <span class="result-value">${result.metadata.creationDate}</span>
                </div>
                <div class="result-item">
                    <span class="result-label">ä¿®æ”¹æ—¥æœŸ:</span>
                    <span class="result-value">${result.metadata.modDate}</span>
                </div>
                <h4>æå–çš„æ—¥æœŸä¿¡æ¯</h4>
                <div class="result-item">
                    <span class="result-label">æ”¶åˆ°æ—¥æœŸ (Received):</span>
                    <span class="result-value">${result.extractedDates.received || 'æœªæ‰¾åˆ°'}${result.extractedDates.receivedNormalized ? ` <span style="color: #28a745;">(${result.extractedDates.receivedNormalized})</span>` : ''}</span>
                </div>
                <div class="result-item">
                    <span class="result-label">ä¿®è®¢æ—¥æœŸ (Revised):</span>
                    <span class="result-value">${result.extractedDates.revised || 'æœªæ‰¾åˆ°'}${result.extractedDates.revisedNormalized ? ` <span style="color: #28a745;">(${result.extractedDates.revisedNormalized})</span>` : ''}</span>
                </div>
                <div class="result-item">
                    <span class="result-label">æ¥å—æ—¥æœŸ (Accepted):</span>
                    <span class="result-value">${result.extractedDates.accepted || 'æœªæ‰¾åˆ°'}${result.extractedDates.acceptedNormalized ? ` <span style="color: #28a745;">(${result.extractedDates.acceptedNormalized})</span>` : ''}</span>
                </div>
                <div class="result-item">
                    <span class="result-label">åœ¨çº¿æ—¥æœŸ (Available online):</span>
                    <span class="result-value">${result.extractedDates.availableOnline || 'æœªæ‰¾åˆ°'}${result.extractedDates.availableOnlineNormalized ? ` <span style="color: #28a745;">(${result.extractedDates.availableOnlineNormalized})</span>` : ''}</span>
                </div>
                <div class="result-item">
                    <span class="result-label">å‘è¡¨æ—¥æœŸ (Published):</span>
                    <span class="result-value">${result.extractedDates.published || 'æœªæ‰¾åˆ°'}${result.extractedDates.publishedNormalized ? ` <span style="color: #28a745;">(${result.extractedDates.publishedNormalized})</span>` : ''}</span>
                </div>
                ${result.extractedDates.other.length > 0 ? `
                <div class="result-item">
                    <span class="result-label">å…¶ä»–æ—¥æœŸ:</span>
                    <span class="result-value">${result.extractedDates.other.map(d => `${d.type}: ${d.value}`).join(', ')}</span>
                </div>
                ` : ''}
                <h4>æ–‡æœ¬é¢„è§ˆï¼ˆå‰500å­—ç¬¦ï¼‰</h4>
                <pre>${result.textPreview || 'æ— æ–‡æœ¬å†…å®¹'}</pre>
            `;
            resultsDiv.appendChild(resultSection);
        }

        // æ˜¾ç¤ºé”™è¯¯
        function displayError(fileName, error) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.innerHTML = `
                <h3>âŒ ${fileName} å¤„ç†å¤±è´¥</h3>
                <p>${error.message || error}</p>
            `;
            resultsDiv.appendChild(errorDiv);
        }
    </script>
</body>
</html>
