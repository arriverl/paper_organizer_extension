<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCRè¯†åˆ«åŠŸèƒ½æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }

        .config-section {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .config-section h3 {
            margin-top: 0;
            color: #667eea;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #666;
        }

        .form-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .upload-area {
            border: 2px dashed #28a745;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #f9f9f9;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            background: #d4edda;
            border-color: #28a745;
        }

        .upload-area.dragover {
            background: #c3e6cb;
            border-color: #1e7e34;
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }

        .btn:hover {
            background: #218838;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .result-area {
            margin-top: 30px;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 8px;
            display: none;
        }

        .result-section {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #28a745;
        }

        .result-section h3 {
            margin-top: 0;
            color: #28a745;
        }

        .result-item {
            margin: 10px 0;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
        }

        .result-label {
            font-weight: bold;
            color: #666;
            margin-right: 10px;
        }

        .result-value {
            color: #333;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #28a745;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .error {
            color: #dc3545;
            background: #f8d7da;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .success {
            color: #28a745;
            background: #d4edda;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .preview-image {
            max-width: 100%;
            max-height: 400px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 10px 0;
        }

        pre {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .info {
            background: #d1ecf1;
            color: #0c5460;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ” OCRè¯†åˆ«åŠŸèƒ½æµ‹è¯•</h1>
        <p>æ­¤å·¥å…·ç”¨äºæµ‹è¯•OCRå¤§æ¨¡å‹APIçš„å›¾ç‰‡è¯†åˆ«åŠŸèƒ½ï¼Œæ”¯æŒå›¾ç‰‡æ–‡ä»¶å’ŒPDFæ–‡ä»¶ï¼ˆæ‰«æä»¶ï¼‰ã€‚</p>

        <div class="config-section">
            <h3>OCR APIé…ç½®</h3>
            <div class="form-group">
                <label for="apiBaseUrl">API Base URL:</label>
                <input type="text" id="apiBaseUrl" value="https://api.tokenpony.cn/v1"
                    placeholder="https://api.tokenpony.cn/v1">
            </div>
            <div class="form-group">
                <label for="apiKey">API Key:</label>
                <input type="text" id="apiKey" value="" placeholder="è¾“å…¥ä½ çš„API Key">
            </div>
            <div class="form-group">
                <label for="apiModel">OCR Model:</label>
                <input type="text" id="apiModel" value="deepseek-ocr" placeholder="deepseek-ocr">
            </div>
            <div class="form-group">
                <label for="llmModel">LLM Model:</label>
                <input type="text" id="llmModel" value="deepseek-v3.2" placeholder="deepseek-v3.2">
            </div>
            <button class="btn btn-secondary" onclick="saveConfig()">ä¿å­˜é…ç½®</button>
        </div>

        <div class="info">
            <strong>æç¤ºï¼š</strong>
            <ul>
                <li>æ”¯æŒå›¾ç‰‡æ–‡ä»¶ï¼šJPG, PNG, GIF, BMPç­‰</li>
                <li>æ”¯æŒPDFæ–‡ä»¶ï¼ˆä¼šè‡ªåŠ¨æ£€æµ‹æ˜¯å¦ä¸ºæ‰«æä»¶ï¼‰</li>
                <li>å¦‚æœæ˜¯æ‰«æä»¶PDFï¼Œä¼šè‡ªåŠ¨å°†é¡µé¢è½¬æ¢ä¸ºå›¾ç‰‡è¿›è¡ŒOCRè¯†åˆ«</li>
                <li>OCRè¯†åˆ«å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´ï¼Œè¯·è€å¿ƒç­‰å¾…</li>
            </ul>
        </div>

        <div class="upload-area" id="uploadArea">
            <p>ğŸ“ ç‚¹å‡»æˆ–æ‹–æ‹½å›¾ç‰‡/PDFæ–‡ä»¶åˆ°è¿™é‡Œ</p>
            <p style="font-size: 12px; color: #666;">æ”¯æŒå•ä¸ªæˆ–å¤šä¸ªæ–‡ä»¶</p>
        </div>
        <input type="file" id="fileInput" accept=".pdf,.jpg,.jpeg,.png,.gif,.bmp" multiple>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>æ­£åœ¨å¤„ç†æ–‡ä»¶å¹¶è¿›è¡ŒOCRè¯†åˆ«...</p>
        </div>

        <div class="result-area" id="resultArea">
            <h2>OCRè¯†åˆ«ç»“æœ</h2>
            <div id="results"></div>
        </div>
    </div>

    <!-- åŠ è½½pdf.jsåº“ï¼ˆç”¨äºPDFå¤„ç†ï¼‰ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // åˆå§‹åŒ–pdf.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // OCRé…ç½®
        let ocrConfig = {
            baseUrl: 'https://api.tokenpony.cn/v1',
            apiKey: '',
            model: 'deepseek-ocr',
            llmModel: 'deepseek-v3.2'
        };

        // ä»localStorageåŠ è½½é…ç½®
        function loadConfig() {
            const saved = localStorage.getItem('ocrConfig');
            if (saved) {
                ocrConfig = JSON.parse(saved);
                document.getElementById('apiBaseUrl').value = ocrConfig.baseUrl;
                document.getElementById('apiKey').value = ocrConfig.apiKey;
                document.getElementById('apiModel').value = ocrConfig.model;
                document.getElementById('llmModel').value = ocrConfig.llmModel || 'deepseek-v3.2';
            }
        }

        // ä¿å­˜é…ç½®
        function saveConfig() {
            ocrConfig = {
                baseUrl: document.getElementById('apiBaseUrl').value,
                apiKey: document.getElementById('apiKey').value,
                model: document.getElementById('apiModel').value,
                llmModel: document.getElementById('llmModel').value || 'deepseek-v3.2'
            };
            localStorage.setItem('ocrConfig', JSON.stringify(ocrConfig));
            alert('é…ç½®å·²ä¿å­˜ï¼');
        }

        // é¡µé¢åŠ è½½æ—¶è¯»å–é…ç½®
        loadConfig();

        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const loading = document.getElementById('loading');
        const resultArea = document.getElementById('resultArea');
        const resultsDiv = document.getElementById('results');

        // ç‚¹å‡»ä¸Šä¼ åŒºåŸŸ
        uploadArea.addEventListener('click', () => {
            fileInput.click();
        });

        // æ–‡ä»¶é€‰æ‹©
        fileInput.addEventListener('change', (e) => {
            handleFiles(Array.from(e.target.files));
        });

        // æ‹–æ”¾åŠŸèƒ½
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files);
            if (files.length > 0) {
                handleFiles(files);
            }
        });

        // å¤„ç†æ–‡ä»¶
        async function handleFiles(files) {
            if (files.length === 0) return;

            // éªŒè¯é…ç½®
            if (!ocrConfig.apiKey) {
                alert('è¯·å…ˆé…ç½®API Keyï¼');
                return;
            }

            loading.classList.add('active');
            resultArea.style.display = 'none';
            resultsDiv.innerHTML = '';

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                try {
                    if (file.name.toLowerCase().endsWith('.pdf')) {
                        const result = await processPdfFile(file);
                        displayResult(file.name, result, i === files.length - 1);
                    } else {
                        const result = await processImageFile(file);
                        displayResult(file.name, result, i === files.length - 1);
                    }
                } catch (error) {
                    displayError(file.name, error);
                }
            }

            loading.classList.remove('active');
            resultArea.style.display = 'block';
        }

        // å¤„ç†å›¾ç‰‡æ–‡ä»¶
        async function processImageFile(file) {
            console.log('å¼€å§‹å¤„ç†å›¾ç‰‡æ–‡ä»¶:', file.name);

            // è¯»å–å›¾ç‰‡ä¸ºbase64
            const imageBase64 = await fileToBase64(file);
            const imageDataUrl = `data:${file.type};base64,${imageBase64}`;

            // ç¬¬ä¸€æ®µï¼šOCRæ¨¡å‹åªè´Ÿè´£æå–å›¾ç‰‡åŸå§‹æ–‡å­—ï¼ˆç›´æ¥è¯†åˆ«æ•´å¼ å›¾ï¼‰
            console.log('[å›¾ç‰‡å¤„ç†] ç¬¬ä¸€æ®µï¼šOCRæå–æ•´å¼ å›¾ç‰‡æ–‡å­—...');
            const ocrText = await ocrExtractText(imageDataUrl);

            // ç¬¬äºŒæ®µï¼šLLMæ¨¡å‹å¯¹OCRæ–‡æœ¬åšç»“æ„åŒ–æ•´ç†
            console.log('[å›¾ç‰‡å¤„ç†] ç¬¬äºŒæ®µï¼šLLMç»“æ„åŒ–æ•´ç†...');
            const llmResult = await structureTextWithLlm(ocrText);

            // é™„å¸¦OCRåŸå§‹æ–‡æœ¬ï¼Œä¾¿äºè°ƒè¯•
            const finalResult = {
                ...llmResult,
                ocrRawText: ocrText
            };

            return {
                success: true,
                fileName: file.name,
                fileSize: file.size,
                fileType: file.type,
                imagePreview: imageDataUrl,
                ocrText: finalResult,
                isPdf: false
            };
        }

        // å¤„ç†PDFæ–‡ä»¶
        async function processPdfFile(file) {
            console.log('å¼€å§‹å¤„ç†PDFæ–‡ä»¶:', file.name);

            // è¯»å–æ–‡ä»¶ä¸ºArrayBuffer
            const arrayBuffer = await file.arrayBuffer();

            // åŠ è½½PDF
            const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
            const pdf = await loadingTask.promise;

            console.log('PDFåŠ è½½æˆåŠŸï¼Œæ€»é¡µæ•°:', pdf.numPages);

            // æ£€æµ‹æ˜¯å¦æ˜¯æ‰«æä»¶
            const isScanned = await isScannedPDF(pdf);
            console.log('æ˜¯å¦æ‰«æä»¶:', isScanned);

            if (!isScanned) {
                // å¦‚æœä¸æ˜¯æ‰«æä»¶ï¼Œæå–æ–‡æœ¬
                let fullText = '';
                const maxPages = Math.min(pdf.numPages, 3);
                for (let i = 1; i <= maxPages; i++) {
                    try {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items.map(item => item.str).join(' ');
                        fullText += pageText + ' ';
                    } catch (error) {
                        console.warn(`è¯»å–ç¬¬${i}é¡µå¤±è´¥:`, error);
                    }
                }

                // PDFæœ‰æ–‡æœ¬æ—¶ï¼šç›´æ¥æŠŠæå–æ–‡æœ¬äº¤ç»™LLMåšç»“æ„åŒ–ï¼ˆæ— éœ€OCRï¼‰
                console.log('[PDFå¤„ç†] PDFåŒ…å«æ–‡æœ¬å†…å®¹ï¼Œå¼€å§‹LLMç»“æ„åŒ–æ•´ç†...');
                const llmResult = await structureTextWithLlm(fullText);
                const finalResult = { ...llmResult, ocrRawText: fullText };

                return {
                    success: true,
                    fileName: file.name,
                    fileSize: file.size,
                    fileType: 'application/pdf',
                    isPdf: true,
                    isScanned: false,
                    extractedText: fullText,
                    ocrText: finalResult,
                    totalPages: pdf.numPages,
                    message: 'PDFåŒ…å«æ–‡æœ¬å†…å®¹ï¼Œå·²ä½¿ç”¨LLMç»“æ„åŒ–ï¼ˆæ— éœ€OCRï¼‰'
                };
            } else {
                // å¦‚æœæ˜¯æ‰«æä»¶ï¼Œè¿›è¡ŒOCRè¯†åˆ«ï¼ˆåªè¯†åˆ«ç¬¬ä¸€é¡µï¼‰
                // ä¼˜å…ˆï¼šç›´æ¥ä»PDFä¸­æå–åŸå§‹JPEGï¼ˆå¸¸è§äºæ‰‹æœºæˆªå›¾å‹PDFï¼‰ï¼Œé¿å…æ¸²æŸ“ç¼©æ”¾å¯¼è‡´OCRå˜å·®
                let imageDataUrl = await extractLargestJpegDataUrlFromPdfArrayBuffer(arrayBuffer);
                if (imageDataUrl) {
                    console.log('[PDFå¤„ç†] å·²ä»PDFå†…ç›´æ¥æå–JPEGç”¨äºOCR');
                } else {
                    console.log('[PDFå¤„ç†] æœªæå–åˆ°JPEGï¼Œå›é€€åˆ°pdf.jsæ¸²æŸ“ä¸ºå›¾ç‰‡');
                    const page = await pdf.getPage(1);
                    // ä½¿ç”¨scale=4æé«˜æ¸²æŸ“è´¨é‡ï¼Œç¡®ä¿OCRè¯†åˆ«å‡†ç¡®
                    const imageBlob = await pdfPageToImage(page, 4);
                    imageDataUrl = await blobToDataUrl(imageBlob);
                    console.log('[PDFå¤„ç†] PDFé¡µé¢å·²æ¸²æŸ“ä¸ºå›¾ç‰‡ï¼Œå°ºå¯¸:', imageBlob.size, 'bytes');
                }

                // ç¬¬ä¸€æ®µï¼šOCRæ¨¡å‹åªè´Ÿè´£æå–å›¾ç‰‡åŸå§‹æ–‡å­—ï¼ˆç›´æ¥è¯†åˆ«æ•´é¡µï¼‰
                console.log('[PDFå¤„ç†] ç¬¬ä¸€æ®µï¼šOCRæå–æ•´é¡µæ–‡å­—...');
                const ocrText = await ocrExtractText(imageDataUrl);

                // ç¬¬äºŒæ®µï¼šLLMæ¨¡å‹å¯¹OCRæ–‡æœ¬åšç»“æ„åŒ–æ•´ç†
                console.log('[PDFå¤„ç†] ç¬¬äºŒæ®µï¼šLLMç»“æ„åŒ–æ•´ç†...');
                const llmResult = await structureTextWithLlm(ocrText);

                const finalResult = {
                    ...llmResult,
                    ocrRawText: ocrText
                };

                return {
                    success: true,
                    fileName: file.name,
                    fileSize: file.size,
                    fileType: 'application/pdf',
                    isPdf: true,
                    isScanned: true,
                    imagePreview: imageDataUrl,
                    ocrText: finalResult,
                    totalPages: pdf.numPages,
                    message: 'PDFæ˜¯æ‰«æä»¶ï¼Œå·²è¿›è¡ŒäºŒæ®µå¼è¯†åˆ«ï¼ˆOCRæå–æ–‡å­— -> LLMç»“æ„åŒ–ï¼‰'
                };
            }
        }

        // æ£€æµ‹PDFæ˜¯å¦æ˜¯æ‰«æä»¶
        async function isScannedPDF(pdf) {
            try {
                const maxPagesToCheck = Math.min(3, pdf.numPages);
                let totalTextLength = 0;

                for (let i = 1; i <= maxPagesToCheck; i++) {
                    try {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items.map(item => item.str).join(' ');
                        totalTextLength += pageText.length;
                    } catch (e) {
                        console.warn(`è¯»å–ç¬¬${i}é¡µå¤±è´¥:`, e);
                    }
                }

                // å¦‚æœå‰3é¡µæ–‡æœ¬å°‘äº100å­—ç¬¦ï¼Œè®¤ä¸ºæ˜¯æ‰«æä»¶
                const isScanned = totalTextLength < 100;
                console.log(`PDFæ–‡æœ¬æ£€æµ‹: å‰${maxPagesToCheck}é¡µå…±${totalTextLength}å­—ç¬¦ï¼Œ${isScanned ? 'å¯èƒ½æ˜¯æ‰«æä»¶' : 'æœ‰æ–‡æœ¬å†…å®¹'}`);
                return isScanned;
            } catch (error) {
                console.error('æ£€æµ‹PDFç±»å‹å¤±è´¥:', error);
                return true; // å‡ºé”™æ—¶é»˜è®¤è®¤ä¸ºæ˜¯æ‰«æä»¶
            }
        }

        // å°†PDFé¡µé¢è½¬æ¢ä¸ºå›¾ç‰‡
        async function pdfPageToImage(page, scale = 4) {
            // ä½¿ç”¨æ›´é«˜çš„scaleå€¼ï¼ˆ4ï¼‰ä»¥ç¡®ä¿åŒ…å«å®Œæ•´é¡µé¢å†…å®¹å’Œæ›´å¥½çš„OCRè¯†åˆ«è´¨é‡
            const viewport = page.getViewport({ scale: scale });
            const canvas = document.createElement('canvas');
            canvas.width = viewport.width;
            canvas.height = viewport.height;

            // è®¾ç½®ç™½è‰²èƒŒæ™¯ï¼Œé¿å…é€æ˜åŒºåŸŸå½±å“OCR
            const context = canvas.getContext('2d');
            context.fillStyle = 'white';
            context.fillRect(0, 0, canvas.width, canvas.height);

            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;

            // å°†canvasè½¬æ¢ä¸ºBlob
            return new Promise((resolve, reject) => {
                canvas.toBlob((blob) => {
                    if (blob) {
                        resolve(blob);
                    } else {
                        reject(new Error('Canvasè½¬Blobå¤±è´¥'));
                    }
                }, 'image/jpeg', 0.95);
            });
        }

        // å°†Blobè½¬æ¢ä¸ºData URL
        function blobToDataUrl(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        // å°è¯•ä»PDFäºŒè¿›åˆ¶ä¸­ç›´æ¥æå–æœ€å¤§JPEGï¼ˆé€‚åˆâ€œå›¾ç‰‡å‹ä¸€é¡µPDFâ€ï¼Œé¿å…pdf.jsé‡æ¸²æŸ“é€ æˆæ¨¡ç³Šï¼‰
        async function extractLargestJpegDataUrlFromPdfArrayBuffer(arrayBuffer) {
            try {
                const bytes = new Uint8Array(arrayBuffer);
                let bestStart = -1;
                let bestEnd = -1;
                let bestLen = 0;

                for (let i = 0; i < bytes.length - 1; i++) {
                    // JPEG SOI: FF D8
                    if (bytes[i] !== 0xFF || bytes[i + 1] !== 0xD8) continue;
                    const start = i;
                    let end = -1;

                    // æ‰¾åˆ°EOI: FF D9
                    for (let j = i + 2; j < bytes.length - 1; j++) {
                        if (bytes[j] === 0xFF && bytes[j + 1] === 0xD9) {
                            end = j + 2;
                            break;
                        }
                    }

                    if (end > start) {
                        const len = end - start;
                        if (len > bestLen) {
                            bestLen = len;
                            bestStart = start;
                            bestEnd = end;
                        }
                        i = end - 1;
                    }
                }

                if (bestStart === -1 || bestEnd === -1 || bestLen < 10_000) {
                    return null;
                }

                const jpegBytes = bytes.slice(bestStart, bestEnd);
                const blob = new Blob([jpegBytes], { type: 'image/jpeg' });
                return await blobToDataUrl(blob);
            } catch (e) {
                console.warn('[PDFå¤„ç†] ç›´æ¥æå–JPEGå¤±è´¥ï¼Œå°†å›é€€åˆ°pdf.jsæ¸²æŸ“:', e);
                return null;
            }
        }

        // å°†æ–‡ä»¶è½¬æ¢ä¸ºbase64
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    // ç§»é™¤data:image/...;base64,å‰ç¼€
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // è§£ææ–°çš„æ–‡æœ¬æ ¼å¼è¾“å‡º
        function parseTextFormatOutput(text) {
            console.log('[æ–‡æœ¬æ ¼å¼è§£æ] å¼€å§‹è§£ææ–‡æœ¬æ ¼å¼è¾“å‡ºï¼Œæ–‡æœ¬é•¿åº¦:', text.length);

            const result = {
                document_type: 'å…¶ä»–',
                title: 'Not mentioned',
                authors: 'Not mentioned',
                dates: {
                    received: 'Not mentioned',
                    revised: 'Not mentioned',
                    accepted: 'Not mentioned',
                    available_online: 'Not mentioned'
                },
                confidence_note: ''
            };

            // è§£ææ–‡æ¡£ç±»å‹
            const docTypeMatch = text.match(/æ–‡æ¡£ç±»å‹:\s*([^\n]+)/i);
            if (docTypeMatch && docTypeMatch[1]) {
                result.document_type = docTypeMatch[1].trim();
                console.log('[æ–‡æœ¬æ ¼å¼è§£æ] æå–åˆ°æ–‡æ¡£ç±»å‹:', result.document_type);
            }

            // è§£ææ ‡é¢˜ï¼ˆæ”¯æŒä¸­è‹±æ–‡æ ¼å¼ï¼‰
            const titleMatch = text.match(/(?:æ ‡é¢˜|Title):\s*([^\n]+)/i);
            if (titleMatch && titleMatch[1]) {
                result.title = titleMatch[1].trim();
                console.log('[æ–‡æœ¬æ ¼å¼è§£æ] æå–åˆ°æ ‡é¢˜:', result.title);
            }

            // è§£æç¬¬ä¸€ä½œè€…ï¼ˆæ”¯æŒä¸­è‹±æ–‡æ ¼å¼ï¼‰
            const firstAuthorMatch = text.match(/(?:ç¬¬ä¸€ä½œè€…|Authors?|Author):\s*([^\n]+)/i);
            if (firstAuthorMatch && firstAuthorMatch[1]) {
                // å¦‚æœæ˜¯å¤šä¸ªä½œè€…ï¼Œåªå–ç¬¬ä¸€ä¸ª
                const authorsStr = firstAuthorMatch[1].trim();
                const firstAuthor = authorsStr.split(',')[0].trim();
                result.authors = firstAuthor;
                console.log('[æ–‡æœ¬æ ¼å¼è§£æ] æå–åˆ°ç¬¬ä¸€ä½œè€…:', result.authors);
            }

            // è§£ææ—¥æœŸä¿¡æ¯ï¼ˆæ”¯æŒä¸­è‹±æ–‡æ ¼å¼ï¼‰
            // æ”¶åˆ°æ—¥æœŸ (Received)
            const receivedMatch = text.match(/(?:æ”¶åˆ°æ—¥æœŸ|Received):\s*([^\n]+)/i);
            if (receivedMatch && receivedMatch[1]) {
                const dateStr = receivedMatch[1].trim();
                if (dateStr !== 'æœªæ‰¾åˆ°' && dateStr !== 'Not mentioned') {
                    result.dates.received = normalizeDateString(dateStr) || dateStr;
                    console.log('[æ–‡æœ¬æ ¼å¼è§£æ] æå–åˆ°æ”¶åˆ°æ—¥æœŸ:', result.dates.received);
                }
            }

            // ä¿®è®¢æ—¥æœŸ (Revised)
            const revisedMatch = text.match(/(?:ä¿®è®¢æ—¥æœŸ|Revised):\s*([^\n]+)/i);
            if (revisedMatch && revisedMatch[1]) {
                const dateStr = revisedMatch[1].trim();
                if (dateStr !== 'æœªæ‰¾åˆ°' && dateStr !== 'Not mentioned') {
                    result.dates.revised = normalizeDateString(dateStr) || dateStr;
                    console.log('[æ–‡æœ¬æ ¼å¼è§£æ] æå–åˆ°ä¿®è®¢æ—¥æœŸ:', result.dates.revised);
                }
            }

            // æ¥å—æ—¥æœŸ (Accepted)
            const acceptedMatch = text.match(/(?:æ¥å—æ—¥æœŸ|Accepted):\s*([^\n]+)/i);
            if (acceptedMatch && acceptedMatch[1]) {
                const dateStr = acceptedMatch[1].trim();
                if (dateStr !== 'æœªæ‰¾åˆ°' && dateStr !== 'Not mentioned') {
                    result.dates.accepted = normalizeDateString(dateStr) || dateStr;
                    console.log('[æ–‡æœ¬æ ¼å¼è§£æ] æå–åˆ°æ¥å—æ—¥æœŸ:', result.dates.accepted);
                }
            }

            // åœ¨çº¿æ—¥æœŸ (Available online)
            const availableMatch = text.match(/(?:åœ¨çº¿æ—¥æœŸ|Available\s+online):\s*([^\n]+)/i);
            if (availableMatch && availableMatch[1]) {
                const dateStr = availableMatch[1].trim();
                if (dateStr !== 'æœªæ‰¾åˆ°' && dateStr !== 'Not mentioned') {
                    result.dates.available_online = normalizeDateString(dateStr) || dateStr;
                    console.log('[æ–‡æœ¬æ ¼å¼è§£æ] æå–åˆ°åœ¨çº¿æ—¥æœŸ:', result.dates.available_online);
                }
            }

            // å°è¯•ä»ISOæ—¥æœŸæ ¼å¼ä¸­æå–ï¼ˆå¦‚ "2025-01-01T00:00:00.000Z"ï¼‰
            const isoDateMatch = text.match(/(\d{4}-\d{2}-\d{2})T\d{2}:\d{2}:\d{2}/);
            if (isoDateMatch && isoDateMatch[1]) {
                const isoDate = isoDateMatch[1];
                // å¦‚æœè¿˜æ²¡æœ‰æ”¶åˆ°æ—¥æœŸï¼Œä½¿ç”¨è¿™ä¸ªæ—¥æœŸ
                if (result.dates.received === 'Not mentioned') {
                    result.dates.received = isoDate;
                    console.log('[æ–‡æœ¬æ ¼å¼è§£æ] ä»ISOæ ¼å¼æå–åˆ°æ”¶åˆ°æ—¥æœŸ:', result.dates.received);
                }
            }

            // æ£€æŸ¥æ˜¯å¦æˆåŠŸæå–äº†è‡³å°‘ä¸€ä¸ªå­—æ®µ
            const hasTitle = result.title && result.title !== 'Not mentioned';
            const hasAuthor = result.authors && result.authors !== 'Not mentioned';
            const hasDate = Object.values(result.dates).some(d => d !== 'Not mentioned');

            if (hasTitle || hasAuthor || hasDate) {
                console.log('[æ–‡æœ¬æ ¼å¼è§£æ] æˆåŠŸè§£ææ–‡æœ¬æ ¼å¼è¾“å‡º');
                return result;
            } else {
                console.log('[æ–‡æœ¬æ ¼å¼è§£æ] æœªèƒ½ä»æ–‡æœ¬æ ¼å¼ä¸­æå–æœ‰æ•ˆä¿¡æ¯');
                return null;
            }
        }

        // ä»çº¯æ–‡æœ¬ä¸­æå–ç»“æ„åŒ–ä¿¡æ¯ï¼ˆå½“JSONè§£æå¤±è´¥æ—¶ä½¿ç”¨ï¼‰
        function extractStructuredInfoFromText(text) {
            console.log('[æ–‡æœ¬è§£æ] å¼€å§‹ä»çº¯æ–‡æœ¬æå–ç»“æ„åŒ–ä¿¡æ¯ï¼Œæ–‡æœ¬é•¿åº¦:', text.length);

            const result = {
                document_type: 'å…¶ä»–',
                title: 'Not mentioned',
                authors: 'Not mentioned',
                dates: {
                    received: 'Not mentioned',
                    revised: 'Not mentioned',
                    accepted: 'Not mentioned',
                    available_online: 'Not mentioned'
                },
                confidence_note: 'ä»çº¯æ–‡æœ¬æå–'
            };

            // åˆ¤æ–­æ–‡æ¡£ç±»å‹
            const lowerText = text.toLowerCase();
            if (lowerText.includes('accepted') || lowerText.includes('å½•ç”¨') || lowerText.includes('acceptance')) {
                result.document_type = 'å½•ç”¨é€šçŸ¥';
            } else if (lowerText.includes('received') || lowerText.includes('submitted') || lowerText.includes('æŠ•ç¨¿')) {
                result.document_type = 'è®ºæ–‡é¦–é¡µ';
            } else if (lowerText.includes('dear') || lowerText.includes('email') || lowerText.includes('@')) {
                result.document_type = 'é‚®ä»¶';
            }

            // æå–æ—¥æœŸï¼ˆæ”¯æŒå¤šç§æ ¼å¼ï¼ŒåŒ…æ‹¬ä¸­æ–‡æ—¥æœŸï¼‰
            // é¦–å…ˆå°è¯•ä»æ˜ç¡®çš„æ—¥æœŸæ ‡ç­¾ä¸­æå–ï¼ˆå¦‚ "Received 1 January 2025"ï¼‰
            const dateLabelPatterns = [
                /Received\s+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/gi,
                /Received\s+in\s+revised\s+form\s+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/gi,
                /Accepted\s+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/gi,
                /Available\s+online\s+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/gi
            ];

            // æå–å¸¦æ ‡ç­¾çš„æ—¥æœŸï¼ˆæ”¯æŒå¤šç§æ ¼å¼ï¼ŒåŒ…æ‹¬åˆ†å·åˆ†éš”çš„å¤šä¸ªæ—¥æœŸï¼‰
            // æ”¯æŒæ ¼å¼ï¼šReceived 1 January 2025; Received in revised form 30 January 2025; Accepted 22 February 2025 Available online 24 February 2025
            const datePattern = /(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/i;

            // é¦–å…ˆå°è¯•åŒ¹é…å®Œæ•´çš„åˆ†å·åˆ†éš”æ ¼å¼ï¼šReceived 1 January 2025; Received in revised form 30 January 2025; Accepted 22 February 2025 Available online 24 February 2025
            const fullDateLineMatch = text.match(/Received\s+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})\s*;\s*Received\s+in\s+revised\s+form\s+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})\s*;\s*Accepted\s+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})\s*(?:Available\s+online\s+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4}))?/i);

            let availableOnlineMatch = null;

            if (fullDateLineMatch) {
                // å¦‚æœåŒ¹é…åˆ°å®Œæ•´çš„åˆ†å·åˆ†éš”æ ¼å¼ï¼Œç›´æ¥æå–
                if (fullDateLineMatch[1]) {
                    const dateStr = normalizeDateString(fullDateLineMatch[1]);
                    if (dateStr) {
                        result.dates.received = dateStr;
                        console.log('[æ–‡æœ¬è§£æ] ä»åˆ†å·åˆ†éš”æ ¼å¼æå–åˆ°receivedæ—¥æœŸ:', dateStr);
                    }
                }
                if (fullDateLineMatch[2]) {
                    const dateStr = normalizeDateString(fullDateLineMatch[2]);
                    if (dateStr) {
                        result.dates.revised = dateStr;
                        console.log('[æ–‡æœ¬è§£æ] ä»åˆ†å·åˆ†éš”æ ¼å¼æå–åˆ°revisedæ—¥æœŸ:', dateStr);
                    }
                }
                if (fullDateLineMatch[3]) {
                    const dateStr = normalizeDateString(fullDateLineMatch[3]);
                    if (dateStr) {
                        result.dates.accepted = dateStr;
                        console.log('[æ–‡æœ¬è§£æ] ä»åˆ†å·åˆ†éš”æ ¼å¼æå–åˆ°acceptedæ—¥æœŸ:', dateStr);
                    }
                }
                if (fullDateLineMatch[4]) {
                    const dateStr = normalizeDateString(fullDateLineMatch[4]);
                    if (dateStr) {
                        result.dates.available_online = dateStr;
                        console.log('[æ–‡æœ¬è§£æ] ä»åˆ†å·åˆ†éš”æ ¼å¼æå–åˆ°available_onlineæ—¥æœŸ:', dateStr);
                    }
                }
            } else {
                // å¦‚æœæ²¡æœ‰åŒ¹é…åˆ°å®Œæ•´æ ¼å¼ï¼Œåˆ†åˆ«åŒ¹é…å„ä¸ªæ—¥æœŸ
                // Receivedæ—¥æœŸ
                const receivedMatch = text.match(/Received[:\s]+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/i) ||
                    text.match(/Received\s+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/i);

                // Revisedæ—¥æœŸï¼ˆæ”¯æŒ"Received in revised form"æ ¼å¼ï¼‰
                const revisedMatch = text.match(/Received\s+in\s+revised\s+form[:\s]+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/i) ||
                    text.match(/Revised[:\s]+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/i);

                // Acceptedæ—¥æœŸ
                const acceptedMatch = text.match(/Accepted[:\s]+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/i) ||
                    text.match(/Accepted\s+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/i);

                // Available onlineæ—¥æœŸ
                availableOnlineMatch = text.match(/Available\s+online[:\s]+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/i) ||
                    text.match(/Available\s+online\s+(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/i);

                // å¤„ç†å„ä¸ªæ—¥æœŸåŒ¹é…ç»“æœ
                if (receivedMatch && receivedMatch[1]) {
                    const dateStr = normalizeDateString(receivedMatch[1]);
                    if (dateStr) {
                        result.dates.received = dateStr;
                        console.log('[æ–‡æœ¬è§£æ] æå–åˆ°receivedæ—¥æœŸ:', dateStr);
                    }
                }

                if (revisedMatch && revisedMatch[1]) {
                    const dateStr = normalizeDateString(revisedMatch[1]);
                    if (dateStr) {
                        result.dates.revised = dateStr;
                        console.log('[æ–‡æœ¬è§£æ] æå–åˆ°revisedæ—¥æœŸ:', dateStr);
                    }
                }

                if (acceptedMatch && acceptedMatch[1]) {
                    const dateStr = normalizeDateString(acceptedMatch[1]);
                    if (dateStr) {
                        result.dates.accepted = dateStr;
                        console.log('[æ–‡æœ¬è§£æ] æå–åˆ°acceptedæ—¥æœŸ:', dateStr);
                    }
                }

                if (availableOnlineMatch && availableOnlineMatch[1]) {
                    const dateStr = normalizeDateString(availableOnlineMatch[1]);
                    if (dateStr) {
                        result.dates.available_online = dateStr;
                        console.log('[æ–‡æœ¬è§£æ] æå–åˆ°available_onlineæ—¥æœŸ:', dateStr);
                    }
                }
            }

            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¸¦æ ‡ç­¾çš„æ—¥æœŸï¼Œå°è¯•ä»æ–‡æœ¬å¼€å¤´æŸ¥æ‰¾æ—¥æœŸï¼ˆå¯èƒ½æ˜¯Available onlineæ—¥æœŸï¼‰
            if (!result.dates.available_online || result.dates.available_online === 'Not mentioned') {
                if (!availableOnlineMatch) {
                    const dateAtStart = text.match(/^(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/i);
                    if (dateAtStart && dateAtStart[1]) {
                        const dateStr = normalizeDateString(dateAtStart[1]);
                        if (dateStr) {
                            result.dates.available_online = dateStr;
                            console.log('[æ–‡æœ¬è§£æ] ä»æ–‡æœ¬å¼€å¤´æå–åˆ°æ—¥æœŸï¼ˆå¯èƒ½æ˜¯Available onlineï¼‰:', dateStr);
                        }
                    }
                }
            }

            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¸¦æ ‡ç­¾çš„æ—¥æœŸï¼Œå°è¯•ä»æ–‡æœ¬å¼€å¤´æŸ¥æ‰¾æ—¥æœŸï¼ˆå¯èƒ½æ˜¯Available onlineæ—¥æœŸï¼‰
            if (!result.dates.available_online || result.dates.available_online === 'Not mentioned') {
                const dateAtStart = text.match(/^(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/i);
                if (dateAtStart && dateAtStart[1]) {
                    const dateStr = normalizeDateString(dateAtStart[1]);
                    if (dateStr) {
                        result.dates.available_online = dateStr;
                        console.log('[æ–‡æœ¬è§£æ] ä»æ–‡æœ¬å¼€å¤´æå–åˆ°æ—¥æœŸï¼ˆå¯èƒ½æ˜¯Available onlineï¼‰:', dateStr);
                    }
                }
            }

            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¸¦æ ‡ç­¾çš„æ—¥æœŸï¼Œå°è¯•é€šç”¨æ—¥æœŸæå–
            if (!result.dates.received && !result.dates.accepted) {
                const datePatterns = [
                    /(\d{4}-\d{2}-\d{2})/g,  // YYYY-MM-DD
                    /(\d{4}\/\d{2}\/\d{2})/g,  // YYYY/MM/DD
                    /(\d{4}å¹´\d{1,2}æœˆ\d{1,2}æ—¥)/g,  // ä¸­æ–‡æ—¥æœŸï¼šYYYYå¹´MMæœˆDDæ—¥
                    /(\d{1,2}\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/gi,  // DD Month YYYY
                    /((?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{1,2},?\s+\d{4})/gi,  // Month DD, YYYY
                    /(\d{1,2}[-\s]+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[-\s]+\d{4})/gi  // DD-Mon-YYYY æˆ– DD Mon YYYYï¼ˆå¦‚ "28-Sep-2025"ï¼‰
                ];

                const dates = [];
                for (const pattern of datePatterns) {
                    const matches = text.matchAll(pattern);
                    for (const match of matches) {
                        let dateStr = match[1];
                        dateStr = normalizeDateString(dateStr);
                        if (dateStr && dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
                            dates.push(dateStr);
                        }
                    }
                }

                // å»é‡æ—¥æœŸ
                const uniqueDates = [...new Set(dates)];
                console.log('[æ–‡æœ¬è§£æ] æ‰¾åˆ°é€šç”¨æ—¥æœŸ:', uniqueDates);

                // æ ¹æ®ä¸Šä¸‹æ–‡åˆ¤æ–­æ—¥æœŸç±»å‹
                if (uniqueDates.length > 0) {
                    const acceptedKeywords = /(accepted|å½•ç”¨|acceptance|decision|pleased to accept)/i;
                    const receivedKeywords = /(received|submitted|æŠ•ç¨¿)/i;

                    if (result.document_type === 'å½•ç”¨é€šçŸ¥' || acceptedKeywords.test(text)) {
                        if (!result.dates.accepted) {
                            result.dates.accepted = uniqueDates[0];
                            console.log('[æ–‡æœ¬è§£æ] è¯†åˆ«ä¸ºacceptedæ—¥æœŸ:', uniqueDates[0]);
                        }
                    } else if (receivedKeywords.test(text)) {
                        if (!result.dates.received) {
                            result.dates.received = uniqueDates[0];
                            console.log('[æ–‡æœ¬è§£æ] è¯†åˆ«ä¸ºreceivedæ—¥æœŸ:', uniqueDates[0]);
                        }
                    }
                }
            }

            // æå–ä½œè€…ï¼ˆä»å¤šä¸ªæ¥æºæå–ï¼‰
            let authorFound = false;
            const authorsList = [];

            // 0. é¦–å…ˆå°è¯•ä»Markdownç²—ä½“æ ¼å¼ä¸­æå–ï¼ˆå¦‚ **Jian Gao, Kexin Jiao, ...**ï¼‰
            // åŒ¹é…æ ¼å¼ï¼š**Name1, Name2, Name3** æˆ– **Name1 Name2**
            const boldAuthorPattern = /\*\*([^*]+)\*\*/g;
            const boldMatches = Array.from(text.matchAll(boldAuthorPattern));
            const boldAuthorCandidates = [];

            // è·³è¿‡ç¬¬ä¸€ä¸ªç²—ä½“å—ï¼ˆé€šå¸¸æ˜¯æ ‡é¢˜ï¼‰ï¼Œä»ç¬¬äºŒä¸ªå¼€å§‹æŸ¥æ‰¾ä½œè€…
            for (let i = 1; i < boldMatches.length; i++) {
                const match = boldMatches[i];
                const content = match[1].trim();
                // æ£€æŸ¥æ˜¯å¦åƒä½œè€…åˆ—è¡¨ï¼ˆåŒ…å«é€—å·åˆ†éš”çš„å¤šä¸ªå§“åï¼Œæˆ–å•ä¸ªå®Œæ•´å§“åï¼‰
                // ä½œè€…åˆ—è¡¨é€šå¸¸ï¼šé•¿åº¦é€‚ä¸­ï¼ˆ20-200å­—ç¬¦ï¼‰ï¼ŒåŒ…å«é€—å·åˆ†éš”çš„å§“å
                if (content.length >= 10 && content.length <= 300) {
                    // æ£€æŸ¥æ˜¯å¦åŒ…å«é€—å·åˆ†éš”çš„å¤šä¸ªå§“åæ ¼å¼
                    if (content.match(/^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)+(?:\s*,\s*[A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)+$/)) {
                        // è¿™çœ‹èµ·æ¥åƒä½œè€…åˆ—è¡¨ï¼ˆå¦‚ "Jian Gao, Kexin Jiao, Jianliang Zhang"ï¼‰
                        boldAuthorCandidates.push({ content: content, index: i });
                    } else if (content.match(/^[A-Z][a-z]+\s+[A-Z][a-z]+$/)) {
                        // å•ä¸ªä½œè€…å
                        boldAuthorCandidates.push({ content: content, index: i });
                    }
                }
            }

            // å¦‚æœæ‰¾åˆ°å¤šä¸ªç²—ä½“å—ï¼Œé€‰æ‹©æœ€åƒä½œè€…åˆ—è¡¨çš„é‚£ä¸ªï¼ˆé€šå¸¸åŒ…å«é€—å·ï¼Œä¸”æ˜¯ç¬¬äºŒä¸ªç²—ä½“å—ï¼‰
            if (boldAuthorCandidates.length > 0) {
                // ä¼˜å…ˆé€‰æ‹©åŒ…å«é€—å·çš„ï¼ˆå¤šä¸ªä½œè€…ï¼‰ï¼Œä¸”ä½ç½®é å‰çš„ï¼ˆé€šå¸¸æ˜¯ç¬¬äºŒä¸ªç²—ä½“å—ï¼‰
                const multiAuthor = boldAuthorCandidates.find(c => c.content.includes(','));
                const selectedAuthor = multiAuthor || boldAuthorCandidates[0];

                // æ¸…ç†ä½œè€…åï¼Œç§»é™¤å¯èƒ½çš„å°¾éƒ¨æ ‡ç‚¹
                let author = selectedAuthor.content.replace(/[ã€‚ï¼Œ,\.:ï¼š]+$/, '').trim();
                // éªŒè¯ï¼šé¿å…æå–åˆ°é”™è¯¯ä¿¡æ¯
                if (author.length > 2 && author.length < 500 &&
                    !author.match(/^(document|type|title|author|date|received|accepted|revised|available|online|not|mentioned|keywords|abstract|article|info)$/i) &&
                    !author.match(/School|University|Laboratory|China|Beijing/i)) { // æ’é™¤å­¦æ ¡ã€å®éªŒå®¤ç­‰ä¿¡æ¯
                    result.authors = author;
                    console.log('[æ–‡æœ¬è§£æ] ä»Markdownç²—ä½“æ ¼å¼æå–åˆ°ä½œè€…ï¼ˆç¬¬' + (selectedAuthor.index + 1) + 'ä¸ªç²—ä½“å—ï¼‰:', result.authors);
                    authorFound = true;
                }
            }

            // 1. ä»é‚®ç®±æ ¼å¼ä¸­æå–ï¼ˆå¦‚ cao_jian2023@163.com (J. Cao) -> Jian Caoï¼‰
            // åŒ¹é…æ ¼å¼ï¼šemail@domain.com (J. Cao) æˆ– email@domain.com (Jian Cao)
            const emailNamePattern = /([a-z0-9_]+)@[^\s)]+\s*\(([A-Z][^)]+)\)/gi;
            let emailNameMatch;
            while ((emailNameMatch = emailNamePattern.exec(text)) !== null) {
                const emailName = emailNameMatch[1].toLowerCase();
                const nameInParen = emailNameMatch[2].trim();
                console.log('[æ–‡æœ¬è§£æ] æ‰¾åˆ°é‚®ç®±æ ¼å¼:', emailName, 'æ‹¬å·å†…:', nameInParen);

                // å¦‚æœæ˜¯ç¼©å†™æ ¼å¼ (J. Cao)ï¼Œä»é‚®ç®±ä¸­æå–å®Œæ•´å§“å
                if (nameInParen.match(/^[A-Z]\.\s+[A-Z][a-z]+$/)) {
                    if (emailName.includes('_')) {
                        const parts = emailName.split('_');
                        // ç§»é™¤æ•°å­—éƒ¨åˆ†ï¼ˆå¦‚ jian2023 -> jianï¼‰
                        const cleanParts = parts.map(p => p.replace(/\d+$/, ''));
                        if (cleanParts.length >= 2 && cleanParts.every(p => p.length >= 2 && p.length <= 15)) {
                            // åè½¬ï¼Œå› ä¸ºé€šå¸¸æ˜¯å_å§“ï¼ˆå¦‚ cao_jian -> Jian Caoï¼‰
                            const formattedName = cleanParts.map(part =>
                                part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
                            ).reverse().join(' ');
                            authorsList.push(formattedName);
                            console.log('[æ–‡æœ¬è§£æ] ä»é‚®ç®±+ç¼©å†™æ ¼å¼æå–åˆ°ä½œè€…:', formattedName);
                        }
                    }
                } else if (nameInParen.match(/^[A-Z][a-z]+\s+[A-Z][a-z]+$/)) {
                    // å¦‚æœå·²ç»æ˜¯å®Œæ•´å§“åï¼Œç›´æ¥ä½¿ç”¨
                    authorsList.push(nameInParen);
                    console.log('[æ–‡æœ¬è§£æ] ä»é‚®ç®±æ ¼å¼æå–åˆ°å®Œæ•´ä½œè€…:', nameInParen);
                }
            }

            // å¦‚æœä»é‚®ç®±æ ¼å¼æå–åˆ°äº†ä½œè€…ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªä½œä¸ºä¸»è¦ä½œè€…
            if (authorsList.length > 0) {
                result.authors = authorsList[0];
                if (authorsList.length > 1) {
                    result.authors = authorsList.join(', ');
                }
                authorFound = true;
            }

            // 2. å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œå°è¯•ä»å•ç‹¬çš„é‚®ç®±åœ°å€ä¸­æå–ï¼ˆå¦‚ jiaokexin@ustb.edu.cn -> Kexin Jiaoï¼‰
            if (!authorFound) {
                const emailPattern = /<([a-z0-9_]+)@[^>]+>/i;
                const emailMatch = text.match(emailPattern);
                if (emailMatch && emailMatch[1]) {
                    const emailName = emailMatch[1].toLowerCase();
                    // å°è¯•ä»ä¸‹åˆ’çº¿æ ¼å¼ä¸­æå–å§“åï¼ˆå¦‚ jiaokexin -> Jiao Kexin æˆ– kexin_jiao -> Kexin Jiaoï¼‰
                    if (emailName.includes('_')) {
                        const parts = emailName.split('_');
                        // ç§»é™¤æ•°å­—éƒ¨åˆ†
                        const cleanParts = parts.map(p => p.replace(/\d+$/, ''));
                        if (cleanParts.length >= 2 && cleanParts.every(p => p.length >= 2 && p.length <= 15)) {
                            // åè½¬ï¼Œå› ä¸ºé€šå¸¸æ˜¯å_å§“
                            const formattedName = cleanParts.map(part =>
                                part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
                            ).reverse().join(' ');
                            result.authors = formattedName;
                            console.log('[æ–‡æœ¬è§£æ] ä»é‚®ç®±æå–åˆ°ä½œè€…:', result.authors);
                            authorFound = true;
                        }
                    }
                }
            }

            // 4. ä»ä¸‹åˆ’çº¿æ ¼å¼çš„å§“åä¸­æå–ï¼ˆå¦‚ "kexin_jiao" -> "Kexin Jiao"ï¼‰
            if (!authorFound) {
                const underscoreNamePattern = /"([a-z]+_[a-z]+)"/i;
                const underscoreMatch = text.match(underscoreNamePattern);
                if (underscoreMatch && underscoreMatch[1]) {
                    const parts = underscoreMatch[1].toLowerCase().split('_');
                    if (parts.length === 2 && parts.every(p => p.length >= 2 && p.length <= 15)) {
                        // åè½¬ï¼Œå› ä¸ºé€šå¸¸æ˜¯å_å§“
                        const formattedName = parts.map(part =>
                            part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
                        ).reverse().join(' ');
                        result.authors = formattedName;
                        console.log('[æ–‡æœ¬è§£æ] ä»ä¸‹åˆ’çº¿æ ¼å¼æå–åˆ°ä½œè€…:', result.authors);
                        authorFound = true;
                    }
                }
            }

            // 3. ä»"Dear Professor"ã€"Dear Dr"ç­‰åé¢çš„åå­—æå–
            if (!authorFound) {
                const authorPatterns = [
                    /Dear\s+(?:Professor|Dr\.?|Mr\.?|Ms\.?|Mrs\.?)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/i,  // Dear Professor Zhan
                    /Dear\s+([A-Z][a-z]+\s+[A-Z][a-z]+)/i,  // Dear First Last
                    /(?:ä½œè€…|Author[s]?|By):\s*([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)/i  // ä½œè€…: xxx
                ];

                for (const pattern of authorPatterns) {
                    const match = text.match(pattern);
                    if (match && match[1]) {
                        let author = match[1].trim();
                        // æ¸…ç†ä½œè€…åï¼Œç§»é™¤å¯èƒ½çš„å°¾éƒ¨æ ‡ç‚¹
                        author = author.replace(/[ã€‚ï¼Œ,\.:ï¼š]+$/, '').trim();
                        // éªŒè¯ï¼šé¿å…æå–åˆ°"Document Type"ç­‰é”™è¯¯ä¿¡æ¯
                        const invalidPatterns = [/^document\s+type$/i, /^title$/i, /^authors?$/i, /^dates?$/i, /^received$/i, /^accepted$/i];
                        if (author.length > 1 && author.length < 100 && !invalidPatterns.some(p => p.test(author))) {
                            result.authors = author;
                            console.log('[æ–‡æœ¬è§£æ] ä»Dearæ ¼å¼æå–åˆ°ä½œè€…:', result.authors);
                            authorFound = true;
                            break;
                        }
                    }
                }
            }

            // 4. å¦‚æœä»é‚®ç®±æå–åˆ°äº†å§“æ°ï¼Œå°è¯•ç»“åˆ"Dear Dr."ä¸­çš„åå­—
            if (authorFound && result.authors && result.authors.split(' ').length === 1) {
                // å¦‚æœåªæå–åˆ°äº†å§“æ°ï¼Œå°è¯•ä»"Dear Dr."ä¸­è·å–å®Œæ•´ä¿¡æ¯
                const dearMatch = text.match(/Dear\s+(?:Professor|Dr\.?|Mr\.?|Ms\.?|Mrs\.?)\s+([a-z]+)/i);
                if (dearMatch && dearMatch[1]) {
                    const dearName = dearMatch[1].toLowerCase();
                    const currentAuthor = result.authors.toLowerCase();
                    // å¦‚æœ"Dear Dr."ä¸­çš„åå­—ä¸å½“å‰ä½œè€…åŒ¹é…ï¼Œä¿æŒå½“å‰æ ¼å¼
                    if (dearName === currentAuthor || currentAuthor.includes(dearName)) {
                        // å·²ç»æ˜¯æ­£ç¡®çš„ï¼Œä¸éœ€è¦ä¿®æ”¹
                    }
                }
            }

            // æå–æ ‡é¢˜ï¼ˆä¼˜å…ˆæŸ¥æ‰¾Markdownæ ¼å¼çš„æ ‡é¢˜ï¼Œç„¶åæŸ¥æ‰¾å…¶ä»–æ ¼å¼ï¼‰
            let titleFound = false;

            // é¦–å…ˆå°è¯•Markdownç²—ä½“æ ¼å¼çš„æ ‡é¢˜ï¼ˆ**Title**ï¼Œé€šå¸¸åœ¨è®ºæ–‡æ ‡é¢˜ä½ç½®ï¼Œæ˜¯ç¬¬ä¸€ä¸ªç²—ä½“å—ï¼‰
            const boldTitlePattern = /\*\*([^*]+)\*\*/g;
            const boldTitleMatches = Array.from(text.matchAll(boldTitlePattern));
            // æ ‡é¢˜é€šå¸¸æ˜¯ç¬¬ä¸€ä¸ªç²—ä½“å—ï¼Œä¸”é•¿åº¦è¾ƒé•¿ï¼ˆè®ºæ–‡æ ‡é¢˜é€šå¸¸æ¯”ä½œè€…åé•¿ï¼‰
            for (let i = 0; i < boldTitleMatches.length; i++) {
                const match = boldTitleMatches[i];
                const content = match[1].trim();
                // æ£€æŸ¥æ˜¯å¦åƒæ ‡é¢˜ï¼ˆé•¿åº¦è¾ƒé•¿ï¼Œä¸åŒ…å«é€—å·åˆ†éš”çš„å¤šä¸ªå§“åæ ¼å¼ï¼‰
                if (content.length > 30 && content.length < 300 &&
                    !content.match(/^[A-Z][a-z]+\s+[A-Z][a-z]+(?:\s*,\s*[A-Z][a-z]+\s+[A-Z][a-z]+)+$/) && // ä¸æ˜¯ä½œè€…åˆ—è¡¨æ ¼å¼
                    !content.match(/^(keywords|abstract|article\s+info|received|accepted|revised|available|online)$/i)) {
                    let title = content.replace(/[ã€‚ï¼Œ,\.]+$/, '').trim();
                    // éªŒè¯ï¼šé¿å…æå–åˆ°é”™è¯¯ä¿¡æ¯
                    const invalidPatterns = [/^document\s+type$/i, /^title$/i, /^authors?$/i, /^dates?$/i, /^article\s+info$/i, /^keywords$/i, /^abstract$/i];
                    if (title.length > 10 && title.length < 300 && !invalidPatterns.some(p => p.test(title))) {
                        result.title = title;
                        console.log('[æ–‡æœ¬è§£æ] ä»Markdownç²—ä½“æ ¼å¼æå–åˆ°æ ‡é¢˜ï¼ˆç¬¬' + (i + 1) + 'ä¸ªç²—ä½“å—ï¼‰:', result.title);
                        titleFound = true;
                        break;
                    }
                }
            }

            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œå°è¯•Markdownæ ¼å¼çš„æ ‡é¢˜ï¼ˆ### æˆ– ## å¼€å¤´ï¼Œé€šå¸¸åœ¨è®ºæ–‡æ ‡é¢˜ä½ç½®ï¼‰
            if (!titleFound) {
                const markdownTitleMatch = text.match(/^#{1,3}\s+(.+)$/m);
                if (markdownTitleMatch && markdownTitleMatch[1]) {
                    let title = markdownTitleMatch[1].trim();
                    // æ¸…ç†æ ‡é¢˜ï¼Œç§»é™¤å¯èƒ½çš„å°¾éƒ¨æ ‡ç‚¹
                    title = title.replace(/[ã€‚ï¼Œ,\.]+$/, '').trim();
                    // éªŒè¯ï¼šé¿å…æå–åˆ°é”™è¯¯ä¿¡æ¯
                    const invalidPatterns = [/^document\s+type$/i, /^title$/i, /^authors?$/i, /^dates?$/i, /^article\s+info$/i, /^keywords$/i, /^abstract$/i, /^introduction$/i];
                    if (title.length > 10 && title.length < 300 && !invalidPatterns.some(p => p.test(title))) {
                        result.title = title;
                        console.log('[æ–‡æœ¬è§£æ] ä»Markdownæ ¼å¼æå–åˆ°æ ‡é¢˜:', result.title);
                        titleFound = true;
                    }
                }
            }

            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°Markdownæ ¼å¼çš„æ ‡é¢˜ï¼Œå°è¯•å…¶ä»–æ ¼å¼
            if (!titleFound) {
                const titlePatterns = [
                    /TITLE:\s*([^\n]+?)(?:\n|$)/i,  // TITLE: åé¢åˆ°æ¢è¡Œ
                    /(?:Title|æ ‡é¢˜):\s*([^\n]+)/i,
                    /(?:Manuscript|Paper|Article):\s*([^\n]+)/i,
                    /(?:Submission|æŠ•ç¨¿):\s*([^\n]+)/i,
                    /^\*\*\*(.+)\*\*\*$/m  // ç²—ä½“æ ¼å¼æ ‡é¢˜
                ];

                for (const pattern of titlePatterns) {
                    const match = text.match(pattern);
                    if (match && match[1]) {
                        let title = match[1].trim();
                        // æ¸…ç†æ ‡é¢˜ï¼Œç§»é™¤Markdownæ ‡è®°å’Œå¯èƒ½çš„å°¾éƒ¨æ ‡ç‚¹
                        title = title.replace(/\*\*/g, '').replace(/[ã€‚ï¼Œ,\.]+$/, '').trim();
                        // éªŒè¯ï¼šé¿å…æå–åˆ°é”™è¯¯ä¿¡æ¯
                        const invalidPatterns = [/^document\s+type$/i, /^title$/i, /^authors?$/i, /^dates?$/i, /^article\s+info$/i, /^keywords$/i, /^abstract$/i];
                        if (title.length > 10 && title.length < 300 && !invalidPatterns.some(p => p.test(title))) {
                            result.title = title;
                            console.log('[æ–‡æœ¬è§£æ] ä»æ ‡ç­¾æå–åˆ°æ ‡é¢˜:', result.title);
                            titleFound = true;
                            break;
                        }
                    }
                }
            }

            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¸¦æ ‡ç­¾çš„æ ‡é¢˜ï¼Œå°è¯•è¯†åˆ«ç‹¬ç«‹çš„é•¿æ–‡æœ¬è¡Œï¼ˆå¯èƒ½æ˜¯è®ºæ–‡æ ‡é¢˜ï¼‰
            if (!titleFound) {
                // æŸ¥æ‰¾åœ¨ç« èŠ‚æ ‡é¢˜ï¼ˆå¦‚"1. Introduction"ã€"Abstract"ï¼‰ä¹‹å‰çš„é•¿æ–‡æœ¬
                // æˆ–è€…æŸ¥æ‰¾åœ¨ä½œè€…ä¿¡æ¯ï¼ˆå¦‚"Correspondence authors"ã€"E-mail addresses"ï¼‰ä¹‹å‰çš„é•¿æ–‡æœ¬
                const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);

                // æ‰¾åˆ°ç¬¬ä¸€ä¸ªç« èŠ‚æ ‡é¢˜æˆ–ä½œè€…ä¿¡æ¯çš„ä½ç½®
                let stopIndex = lines.length;
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    // æ£€æµ‹ç« èŠ‚æ ‡é¢˜æˆ–ä½œè€…ä¿¡æ¯å¼€å§‹çš„ä½ç½®
                    if (line.match(/^\d+\.\s+[A-Z]/) || // ç« èŠ‚æ ‡é¢˜ï¼ˆå¦‚ "1. Introduction"ï¼‰
                        line.match(/^Abstract|Introduction|Keywords|References/i) || // å¸¸è§ç« èŠ‚æ ‡é¢˜
                        line.match(/^Correspondence\s+authors?/i) || // "Correspondence authors"
                        line.match(/^E-mail\s+addresses?/i) || // "E-mail addresses"
                        line.match(/^Received\s+\d/i) || // æ—¥æœŸä¿¡æ¯å¼€å§‹
                        line.match(/^https?:\/\//i) || // URLå¼€å§‹
                        line.match(/^[a-z0-9_]+@/i)) { // é‚®ç®±å¼€å§‹
                        stopIndex = i;
                        console.log('[æ–‡æœ¬è§£æ] æ‰¾åˆ°ç« èŠ‚/ä½œè€…/æ—¥æœŸå¼€å§‹ä½ç½®:', i, 'è¡Œå†…å®¹:', line);
                        break;
                    }
                }

                // åœ¨åœæ­¢ä½ç½®ä¹‹å‰æŸ¥æ‰¾æ ‡é¢˜
                const titleCandidates = [];
                // å…ˆå°è¯•æ‰¾åˆ°ç¬¬ä¸€ä¸ªç²—ä½“å—ï¼ˆæ ‡é¢˜ï¼‰ï¼Œä¸è¦åˆå¹¶åé¢çš„å†…å®¹
                for (let i = 0; i < stopIndex && i < lines.length; i++) {
                    const line = lines[i];

                    // æ£€æŸ¥æ˜¯å¦æ˜¯Markdownç²—ä½“æ ¼å¼çš„æ ‡é¢˜ï¼ˆ**Title**ï¼‰
                    const boldMatch = line.match(/\*\*([^*]+)\*\*/);
                    if (boldMatch && boldMatch[1]) {
                        const content = boldMatch[1].trim();
                        // æ£€æŸ¥æ˜¯å¦åƒæ ‡é¢˜ï¼ˆé•¿åº¦è¾ƒé•¿ï¼Œä¸åŒ…å«é€—å·åˆ†éš”çš„å¤šä¸ªå§“åæ ¼å¼ï¼‰
                        if (content.length > 30 && content.length < 300 &&
                            !content.match(/^[A-Z][a-z]+\s+[A-Z][a-z]+(?:\s*,\s*[A-Z][a-z]+\s+[A-Z][a-z]+)+$/) && // ä¸æ˜¯ä½œè€…åˆ—è¡¨æ ¼å¼
                            !content.match(/^(keywords|abstract|article\s+info|received|accepted|revised|available|online)$/i) &&
                            !content.match(/School|University|Laboratory|China|Beijing/i)) { // æ’é™¤å­¦æ ¡ã€å®éªŒå®¤ç­‰ä¿¡æ¯
                            let title = content.replace(/[ã€‚ï¼Œ,\.]+$/, '').trim();
                            // éªŒè¯ï¼šé¿å…æå–åˆ°é”™è¯¯ä¿¡æ¯
                            const invalidPatterns = [/^document\s+type$/i, /^title$/i, /^authors?$/i, /^dates?$/i, /^article\s+info$/i, /^keywords$/i, /^abstract$/i];
                            if (title.length > 10 && title.length < 300 && !invalidPatterns.some(p => p.test(title))) {
                                result.title = title;
                                console.log('[æ–‡æœ¬è§£æ] ä»ç‹¬ç«‹è¡Œæå–åˆ°æ ‡é¢˜ï¼ˆç²—ä½“æ ¼å¼ï¼‰:', result.title);
                                titleFound = true;
                                break;
                            }
                        }
                    }

                    // è·³è¿‡æ˜æ˜¾çš„éæ ‡é¢˜å†…å®¹
                    if (line.length < 15 || // å¤ªçŸ­
                        line.length > 300 || // å¤ªé•¿
                        line.match(/^\d{4}-\d{2}-\d{2}/) || // æ—¥æœŸæ ¼å¼
                        line.match(/^[<>]/) || // é‚®ç®±æ ¼å¼
                        line.match(/^Dear\s+/i) || // Dearå¼€å¤´
                        line.match(/^Decision\s+on/i) || // Decisionå¼€å¤´
                        line.match(/^Manuscript\s+Number/i) || // Manuscript Number
                        line.match(/^æ˜¾ç¤ºç¿»è¯‘|åˆ é™¤|åˆ†äº«|å›å¤|è½¬å‘|æ›´å¤š/) || // æ“ä½œæŒ‰é’®
                        line.match(/^å¯é€‰è¯´æ˜|confidence_note/i) || // promptæ®‹ç•™
                        line.match(/^document\s+type|title|authors?|dates?/i) || // å­—æ®µå
                        line.match(/^\d{4}$/) || // åªæœ‰å¹´ä»½ï¼ˆå¦‚"2025"ï¼‰
                        line.match(/^:\s*\d{4}$/) || // åªæœ‰": 2025"è¿™æ ·çš„æ ¼å¼
                        line.match(/^\d{4}\s*$/) || // åªæœ‰å¹´ä»½åŠ ç©ºæ ¼
                        line.match(/^ISSN:|JCR:|Scopus:|Google\s+Scholar:/i) || // æœŸåˆŠä¿¡æ¯
                        line.match(/^\d{4}-\d{7}/) || // ISSNæ ¼å¼
                        line.match(/School|University|Laboratory|China|Beijing/i) || // å­¦æ ¡ã€å®éªŒå®¤ç­‰ä¿¡æ¯
                        !line.match(/[a-zA-Z]/) || // ä¸åŒ…å«å­—æ¯
                        line.match(/^[:\s]*$/)) { // åªæœ‰æ ‡ç‚¹
                        continue;
                    }

                    // å¦‚æœè¿™ä¸€è¡Œçœ‹èµ·æ¥åƒæ ‡é¢˜ï¼ˆç‹¬ç«‹çš„é•¿æ–‡æœ¬è¡Œï¼Œä¸åŒ…å«ä½œè€…ã€å­¦æ ¡ç­‰ä¿¡æ¯ï¼‰
                    if (line.length >= 15 && line.length <= 300 && line.match(/[a-zA-Z]/) &&
                        !line.match(/^[A-Z][a-z]+\s+[A-Z][a-z]+(?:\s*,\s*[A-Z][a-z]+\s+[A-Z][a-z]+)+$/) && // ä¸æ˜¯ä½œè€…åˆ—è¡¨æ ¼å¼
                        !line.match(/School|University|Laboratory|China|Beijing/i)) { // ä¸åŒ…å«å­¦æ ¡ã€å®éªŒå®¤ç­‰ä¿¡æ¯
                        titleCandidates.push({
                            line: line,
                            index: i,
                            length: line.length
                        });
                    }
                }

                // å¦‚æœæ‰¾åˆ°äº†æ ‡é¢˜å€™é€‰ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªï¼ˆé€šå¸¸æ˜¯æœ€é å‰çš„ï¼‰
                if (titleCandidates.length > 0 && !titleFound) {
                    const bestCandidate = titleCandidates[0];
                    let title = bestCandidate.line.replace(/\*\*/g, '').replace(/[ã€‚ï¼Œ,\.]+$/, '').trim();
                    result.title = title;
                    console.log('[æ–‡æœ¬è§£æ] ä»ç‹¬ç«‹è¡Œæå–åˆ°æ ‡é¢˜:', result.title, 'ä½ç½®:', bestCandidate.index);
                    titleFound = true;
                }

                if (!titleFound) {
                    // å¦‚æœåˆå¹¶å¤±è´¥ï¼Œå°è¯•æŸ¥æ‰¾å•ä¸ªæœ€é•¿çš„åˆç†è¡Œä½œä¸ºæ ‡é¢˜
                    const titleCandidates = [];
                    for (let i = 0; i < stopIndex && i < lines.length; i++) {
                        const line = lines[i];

                        // è·³è¿‡æ˜æ˜¾çš„éæ ‡é¢˜å†…å®¹
                        if (line.length < 15 || // å¤ªçŸ­
                            line.length > 300 || // å¤ªé•¿
                            line.match(/^\d{4}-\d{2}-\d{2}/) || // æ—¥æœŸæ ¼å¼
                            line.match(/^[<>]/) || // é‚®ç®±æ ¼å¼
                            line.match(/^Dear\s+/i) || // Dearå¼€å¤´
                            line.match(/^Decision\s+on/i) || // Decisionå¼€å¤´
                            line.match(/^Manuscript\s+Number/i) || // Manuscript Number
                            line.match(/^æ˜¾ç¤ºç¿»è¯‘|åˆ é™¤|åˆ†äº«|å›å¤|è½¬å‘|æ›´å¤š/) || // æ“ä½œæŒ‰é’®
                            line.match(/^å¯é€‰è¯´æ˜|confidence_note/i) || // promptæ®‹ç•™
                            line.match(/^document\s+type|title|authors?|dates?/i) || // å­—æ®µå
                            line.match(/^\d{4}$/) || // åªæœ‰å¹´ä»½ï¼ˆå¦‚"2025"ï¼‰
                            line.match(/^ISSN:|JCR:|Scopus:|Google\s+Scholar:/i) || // æœŸåˆŠä¿¡æ¯
                            line.match(/^\d{4}-\d{7}/) || // ISSNæ ¼å¼
                            line.match(/^:\s*\d{4}$/) || // åªæœ‰": 2025"è¿™æ ·çš„æ ¼å¼
                            line.match(/^\d{4}\s*$/) || // åªæœ‰å¹´ä»½åŠ ç©ºæ ¼
                            !line.match(/[a-zA-Z]/) || // ä¸åŒ…å«å­—æ¯
                            line.match(/^[:\s]*$/)) { // åªæœ‰æ ‡ç‚¹
                            continue;
                        }

                        // æ£€æŸ¥æ˜¯å¦åƒæ ‡é¢˜
                        const words = line.split(/\s+/).filter(w => w.length > 0);
                        if (words.length >= 3 && words.length <= 50) {
                            // æ ‡é¢˜é€šå¸¸åŒ…å«å¤šä¸ªå•è¯ï¼Œä¸”å¾ˆå¤šå•è¯é¦–å­—æ¯å¤§å†™
                            const capitalizedWords = words.filter(w => /^[A-Z]/.test(w)).length;
                            const totalWords = words.length;
                            const capitalRatio = capitalizedWords / totalWords;

                            // å¦‚æœè‡³å°‘30%çš„å•è¯é¦–å­—æ¯å¤§å†™ï¼Œæˆ–è€…å•è¯æ•°è¾ƒå¤šï¼ˆå¯èƒ½æ˜¯æ ‡é¢˜ï¼‰
                            if (capitalRatio >= 0.3 || (totalWords >= 5 && capitalRatio >= 0.2)) {
                                titleCandidates.push({
                                    line: line,
                                    index: i,
                                    length: line.length,
                                    words: totalWords,
                                    capitalRatio: capitalRatio
                                });
                                console.log('[æ–‡æœ¬è§£æ] æ‰¾åˆ°æ ‡é¢˜å€™é€‰:', i, line.substring(0, 50) + '...', 'å•è¯æ•°:', totalWords, 'å¤§å†™æ¯”ä¾‹:', capitalRatio.toFixed(2));
                            }
                        }
                    }

                    // é€‰æ‹©æœ€ä½³æ ‡é¢˜å€™é€‰ï¼ˆé€šå¸¸æ˜¯æœ€é•¿çš„ã€ä½ç½®é å‰çš„ï¼‰
                    if (titleCandidates.length > 0) {
                        // ä¼˜å…ˆé€‰æ‹©ä½ç½®é å‰ä¸”é•¿åº¦é€‚ä¸­çš„
                        titleCandidates.sort((a, b) => {
                            // é¦–å…ˆæŒ‰ä½ç½®ï¼ˆè¶Šé å‰è¶Šå¥½ï¼‰
                            if (a.index !== b.index) return a.index - b.index;
                            // ç„¶åæŒ‰é•¿åº¦ï¼ˆè¶Šé•¿è¶Šå¥½ï¼Œä½†ä¸è¦å¤ªé•¿ï¼‰
                            return b.length - a.length;
                        });

                        const bestCandidate = titleCandidates[0];
                        result.title = bestCandidate.line;
                        console.log('[æ–‡æœ¬è§£æ] é€‰æ‹©æœ€ä½³æ ‡é¢˜å€™é€‰:', result.title, 'ä½ç½®:', bestCandidate.index, 'é•¿åº¦:', bestCandidate.length);
                        titleFound = true;
                    }
                }
            }

            // æå–ç¨¿ä»¶ç¼–å·ï¼ˆæ”¯æŒå¤šç§æ ¼å¼ï¼‰
            const manuscriptPatterns = [
                /Manuscript\s+Number:\s*([A-Z0-9\-\.]+R?\d*)/i,  // Manuscript Number: EFA-D-25-00003R1
                /Manuscript\s+ID:\s*([A-Z0-9\-\.]+R?\d*)/i,  // Manuscript ID: NR-ART-07-2025-003036.R1
                /(?:Manuscript|Paper|Article|ç¨¿ä»¶)[\s#:]*([A-Z]+-D-\d+-\d+R?\d*)/i,  // ENGSTRUCT-D-25-05223R2
                /(?:ID|ç¼–å·)[\s#:]*([A-Z0-9\-\.]+R?\d*)/i  // ID: xxx
            ];

            for (const pattern of manuscriptPatterns) {
                const manuscriptMatch = text.match(pattern);
                if (manuscriptMatch && manuscriptMatch[1]) {
                    const manuscriptId = manuscriptMatch[1].trim();
                    // éªŒè¯ï¼šé¿å…æå–åˆ°é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚"ence"ã€"Document"ç­‰ï¼‰
                    // ç¨¿ä»¶ç¼–å·åº”è¯¥åŒ…å«è‡³å°‘ä¸€ä¸ªæ•°å­—ï¼Œé•¿åº¦è‡³å°‘5ä¸ªå­—ç¬¦
                    if (manuscriptId.length >= 5 &&
                        manuscriptId.match(/\d/) && // åŒ…å«æ•°å­—
                        !manuscriptId.match(/^(document|type|title|author|date|received|accepted|revised|available|online|not|mentioned)$/i) && // ä¸æ˜¯å¸¸è§å­—æ®µå
                        !manuscriptId.match(/^[a-z]{1,4}$/i)) { // ä¸æ˜¯çŸ­å•è¯ï¼ˆå¦‚"ence"ï¼‰
                        result.confidence_note = `ç¨¿ä»¶ç¼–å·: ${manuscriptId}`;
                        console.log('[æ–‡æœ¬è§£æ] æå–åˆ°ç¨¿ä»¶ç¼–å·:', manuscriptId);
                        break;
                    } else {
                        console.log('[æ–‡æœ¬è§£æ] ç¨¿ä»¶ç¼–å·éªŒè¯å¤±è´¥ï¼Œè·³è¿‡:', manuscriptId);
                    }
                }
            }

            return result;
        }

        // æ ‡å‡†åŒ–æ—¥æœŸå­—ç¬¦ä¸²ä¸º YYYY-MM-DD æ ¼å¼
        function normalizeDateString(dateStr) {
            if (!dateStr) return '';

            // å¦‚æœå·²ç»æ˜¯YYYY-MM-DDæ ¼å¼
            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                return dateStr;
            }

            // å¤„ç†ä¸­æ–‡æ—¥æœŸæ ¼å¼ï¼šYYYYå¹´MMæœˆDDæ—¥
            const chineseDateMatch = dateStr.match(/(\d{4})å¹´(\d{1,2})æœˆ(\d{1,2})æ—¥/);
            if (chineseDateMatch) {
                const year = chineseDateMatch[1];
                const month = chineseDateMatch[2].padStart(2, '0');
                const day = chineseDateMatch[3].padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            // å¤„ç† YYYY/MM/DD æ ¼å¼
            const ymdMatch = dateStr.match(/(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})/);
            if (ymdMatch) {
                const year = ymdMatch[1];
                const month = ymdMatch[2].padStart(2, '0');
                const day = ymdMatch[3].padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            // å¤„ç† "Month DD, YYYY" æ ¼å¼
            const monthDayYearMatch = dateStr.match(/([A-Z][a-z]+)\s+(\d{1,2}),?\s+(\d{4})/);
            if (monthDayYearMatch) {
                const monthNames = {
                    'January': '01', 'February': '02', 'March': '03', 'April': '04',
                    'May': '05', 'June': '06', 'July': '07', 'August': '08',
                    'September': '09', 'October': '10', 'November': '11', 'December': '12'
                };
                const month = monthNames[monthDayYearMatch[1]];
                if (month) {
                    const day = monthDayYearMatch[2].padStart(2, '0');
                    const year = monthDayYearMatch[3];
                    return `${year}-${month}-${day}`;
                }
            }

            // å¤„ç† "DD Month YYYY" æ ¼å¼
            const dayMonthYearMatch = dateStr.match(/(\d{1,2})\s+([A-Z][a-z]+)\s+(\d{4})/);
            if (dayMonthYearMatch) {
                const monthNames = {
                    'January': '01', 'February': '02', 'March': '03', 'April': '04',
                    'May': '05', 'June': '06', 'July': '07', 'August': '08',
                    'September': '09', 'October': '10', 'November': '11', 'December': '12',
                    'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',
                    'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08',
                    'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12'
                };
                const month = monthNames[dayMonthYearMatch[2]];
                if (month) {
                    const day = dayMonthYearMatch[1].padStart(2, '0');
                    const year = dayMonthYearMatch[3];
                    return `${year}-${month}-${day}`;
                }
            }

            // å¤„ç† "DD-Mon-YYYY" æ ¼å¼ï¼ˆå¦‚ "28-Sep-2025"ï¼‰
            const dayMonYearMatch = dateStr.match(/(\d{1,2})[-\s]+([A-Z][a-z]{2,3})[-\s]+(\d{4})/);
            if (dayMonYearMatch) {
                const monthNames = {
                    'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',
                    'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08',
                    'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12'
                };
                const month = monthNames[dayMonYearMatch[2]];
                if (month) {
                    const day = dayMonYearMatch[1].padStart(2, '0');
                    const year = dayMonYearMatch[3];
                    return `${year}-${month}-${day}`;
                }
            }

            return '';
        }

        // è·å–å­¦æœ¯æ–‡æ¡£æå–çš„OCRæç¤ºè¯
        function getAcademicOcrPrompt() {
            // äºŒæ®µå¼æµç¨‹çš„ç¬¬äºŒæ®µï¼šLLMä»OCRæ–‡æœ¬ä¸­æå–ç»“æ„åŒ–ä¿¡æ¯
            // é€‚é…é‚®ä»¶åœºæ™¯ï¼Œä¸è¦å› ä¸ºçœ‹åˆ°"æ”¶ä»¶ç®±"å°±åˆ¤æ–­ä¸ºç•Œé¢
            return `ä½ æ˜¯å­¦æœ¯æ–‡æ¡£ä¿¡æ¯æŠ½å–åŠ©æ‰‹ã€‚ä¸‹é¢æ˜¯OCRè¯†åˆ«å¾—åˆ°çš„åŸå§‹æ–‡æœ¬ï¼ˆå¯èƒ½åŒ…å«è®ºæ–‡é¦–é¡µã€å½•ç”¨é€šçŸ¥ã€é‚®ä»¶ã€ç½‘é¡µæˆªå›¾ç­‰ï¼‰ã€‚è¯·ä»ä¸­æå–è®ºæ–‡å…³é”®ä¿¡æ¯å¹¶è¾“å‡ºä¸¥æ ¼JSONã€‚

é‡è¦æç¤ºï¼š
1) å¦‚æœæ–‡æœ¬ä¸­åŒ…å«"æ”¶ä»¶ç®±"ã€"è‰ç¨¿ç®±"ç­‰é‚®ç®±ç•Œé¢è¯æ±‡ï¼Œä½†åŒæ—¶ä¹ŸåŒ…å«è®ºæ–‡ç›¸å…³ä¿¡æ¯ï¼ˆå¦‚è®ºæ–‡åç§°ã€ä½œè€…ã€å½•ç”¨æ—¥æœŸç­‰ï¼‰ï¼Œè¯·åˆ¤æ–­ä¸ºã€é‚®ä»¶ã€‘ç±»å‹ï¼Œå¹¶æå–å…¶ä¸­çš„è®ºæ–‡ä¿¡æ¯ã€‚
2) ä¸è¦å› ä¸ºå‡ºç°"æ”¶ä»¶ç®±"å°±åˆ¤ä¸ºç•Œé¢ï¼Œè¦æ£€æŸ¥æ˜¯å¦åŒ…å«å®é™…çš„è®ºæ–‡/å½•ç”¨ä¿¡æ¯ã€‚
3) å¯¹äºé‚®ä»¶åœºæ™¯ï¼Œé‡ç‚¹å…³æ³¨ï¼šé‚®ä»¶ä¸»é¢˜/æ‰˜ä¸¾å¯¹è±¡ã€è®ºæ–‡åç§°ã€ä½œè€…ã€å½•ç”¨æ—¥æœŸã€å‘ä»¶äººé‚®ç®±ç­‰ä¿¡æ¯ã€‚

è¦æ±‚ï¼š
1) åªè¾“å‡ºä¸€ä¸ªJSONå¯¹è±¡ï¼Œä¸è¦è¾“å‡ºä»»ä½•é¢å¤–æ–‡å­—ã€ä¸è¦ä½¿ç”¨Markdownä»£ç å—ã€‚
2) è‹¥ç¼ºå¤±ï¼Œå¡«å†™ "Not mentioned"ã€‚
3) æ—¥æœŸè¯·å°½é‡æ ‡å‡†åŒ–ä¸º YYYY-MM-DDï¼›è‹¥åªå‡ºç°åˆ°æœˆä»½/å¹´ä»½ï¼Œä¿ç•™åŸæ ·å¹¶åœ¨ confidence_note è¯´æ˜ä¸ç¡®å®šæ€§ã€‚

è¾“å‡ºJSONæ ¼å¼ï¼ˆå­—æ®µåå¿…é¡»ä¸€è‡´ï¼‰ï¼š
{
  "document_type": "[è®ºæ–‡é¦–é¡µ/å½•ç”¨é€šçŸ¥/é‚®ä»¶/å…¶ä»–]",
  "title": "",
  "authors": "",
  "dates": {
    "received": "",
    "revised": "",
    "accepted": "",
    "available_online": ""
  },
  "confidence_note": ""
}`;
        }

        // ç¬¬ä¸€æ®µï¼šOCRåªæå–åŸå§‹æ–‡å­—ï¼ˆä¸åšç»“æ„åŒ–ï¼‰
        function getOcrPureTextPrompt() {
            // æ˜ç¡®è¦æ±‚æå–å…¨éƒ¨å¯è§æ–‡å­—ï¼Œä¸è¦åšé‚®ç®±ç•Œé¢åˆ¤æ–­ï¼Œä¸è¦åŠ å…¥å ä½ç¬¦
            // æ³¨æ„ï¼šä½¿ç”¨image_urlæ ¼å¼æ—¶ï¼Œæç¤ºè¯ä¸­ä¸éœ€è¦<image>å ä½ç¬¦
            return 'è¯·åªè¿”å›å›¾ç‰‡/PDFé¡µé¢ä¸­çš„**å…¨éƒ¨å¯è§æ–‡å­—**ï¼ŒæŒ‰ä»ä¸Šåˆ°ä¸‹é¡ºåºé€è¡Œè¾“å‡ºã€‚ä¸è¦åšé‚®ç®±ç•Œé¢åˆ¤æ–­ï¼Œä¸è¦åŠ å…¥---å ä½ç¬¦ï¼Œä¸è¦è¾“å‡ºJSONï¼Œä¸è¦æ€»ç»“ã€‚è¾“å‡ºæ‰€æœ‰è¯†åˆ«åˆ°çš„æ–‡å­—ï¼ŒåŒ…æ‹¬æ ‡é¢˜ã€æ­£æ–‡ã€æ—¥æœŸã€ä½œè€…ç­‰æ‰€æœ‰å†…å®¹ã€‚';
        }

        function isDegenerateOcrOutput(text) {
            const t = String(text || '').replace(/\s+/g, '');
            if (t.length < 50) return false;
            const counts = {};
            for (const ch of t) counts[ch] = (counts[ch] || 0) + 1;
            const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]);
            const unique = entries.length;
            const topCount = entries[0]?.[1] || 0;
            const topRatio = topCount / t.length;
            if (unique <= 3 && topRatio > 0.8) return true;
            if (/^[\}\]\)\{\[,.:;"'`~!@#$%^&*+=<>|\\/-]+$/.test(t) && topRatio > 0.6) return true;
            return false;
        }

        async function callChatCompletions({ model, messages, temperature = 0, max_tokens = 2048 }) {
            if (!ocrConfig.baseUrl) throw new Error('è¯·å…ˆé…ç½®API Base URL');
            if (!ocrConfig.apiKey) throw new Error('è¯·å…ˆé…ç½®API Key');
            if (!model) throw new Error('æ¨¡å‹æœªé…ç½®');

            const apiUrl = `${ocrConfig.baseUrl.replace(/\/$/, '')}/chat/completions`;
            const requestBody = {
                model,
                messages,
                temperature,
                max_tokens,
                stream: false
            };

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${ocrConfig.apiKey}`
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText} - ${errorText}`);
            }

            const data = await response.json();
            const content = data?.choices?.[0]?.message?.content;
            if (!content) {
                throw new Error('APIè¿”å›å†…å®¹ä¸ºç©º');
            }
            return { content, data };
        }

        // ç¬¬ä¸€æ®µï¼šè°ƒç”¨OCRæ¨¡å‹æå–å›¾ç‰‡æ–‡å­—
        async function ocrExtractText(imageDataUrl, prompt = null) {
            const primaryPrompt = prompt || getOcrPureTextPrompt();
            const retryPrompts = [
                primaryPrompt,
                'è¯·åªè¿”å›å›¾ç‰‡ä¸­çš„å…¨éƒ¨å¯è§æ–‡å­—ï¼Œé€è¡Œè¾“å‡ºã€‚ä¸è¦åšç•Œé¢åˆ¤æ–­ï¼Œä¸è¦åŠ å…¥å ä½ç¬¦ã€‚',
                'Extract all visible text from the image line by line. Output only the text, no placeholders.'
            ];

            console.log('[OCR-1] å¼€å§‹æå–å›¾ç‰‡æ–‡å­—...');
            const match = imageDataUrl.match(/data:([^;]+);base64,(.+)/);
            if (!match) {
                throw new Error('æ— æ•ˆçš„å›¾ç‰‡æ•°æ®URL');
            }

            let lastContent = '';
            for (let i = 0; i < retryPrompts.length; i++) {
                const currentPrompt = retryPrompts[i];
                console.log(`[OCR-1] å°è¯•ç¬¬${i + 1}æ¬¡ï¼Œpromptå‰40å­—ç¬¦:`, currentPrompt.substring(0, 40));

                const { content } = await callChatCompletions({
                    model: ocrConfig.model,
                    messages: [
                        {
                            role: 'user',
                            content: [
                                { type: 'text', text: currentPrompt },
                                { type: 'image_url', image_url: { url: imageDataUrl, detail: 'high' } }
                            ]
                        }
                    ],
                    temperature: 0,
                    max_tokens: 4096
                });

                lastContent = content;
                if (!isDegenerateOcrOutput(content)) {
                    console.log('[OCR-1] âœ“ OCRå®Œæˆï¼Œæ–‡æœ¬é•¿åº¦:', content.length);
                    return content;
                }

                console.warn('[OCR-1] æ£€æµ‹åˆ°å¼‚å¸¸è¾“å‡ºï¼ˆä½å¤šæ ·æ€§/é‡å¤ç¬¦å·ï¼‰ï¼Œå‡†å¤‡é‡è¯•...');
            }

            console.warn('[OCR-1] å¤šæ¬¡é‡è¯•åä»å¼‚å¸¸ï¼Œè¿”å›æœ€åä¸€æ¬¡è¾“å‡º');
            return lastContent;
        }

        function extractJsonFromText(text) {
            if (!text) return { json: null, error: 'empty' };

            const tryParse = (jsonStr) => {
                try {
                    return { json: JSON.parse(jsonStr), error: null };
                } catch (e) {
                    return { json: null, error: e.message };
                }
            };

            const jsonBlock = text.match(/```json\s*([\s\S]*?)\s*```/i);
            if (jsonBlock?.[1]) return tryParse(jsonBlock[1]);

            const codeBlock = text.match(/```\s*([\s\S]*?)\s*```/);
            if (codeBlock?.[1]) return tryParse(codeBlock[1]);

            let braceCount = 0;
            let start = -1;
            for (let i = 0; i < text.length; i++) {
                const ch = text[i];
                if (ch === '{') {
                    if (braceCount === 0) start = i;
                    braceCount++;
                } else if (ch === '}') {
                    braceCount--;
                    if (braceCount === 0 && start !== -1) {
                        const candidate = text.slice(start, i + 1);
                        const parsed = tryParse(candidate);
                        if (parsed.json) return parsed;
                        start = -1;
                    }
                }
            }

            const matches = text.match(/\{[\s\S]*\}/g);
            if (matches?.length) {
                matches.sort((a, b) => b.length - a.length);
                for (const m of matches) {
                    const parsed = tryParse(m);
                    if (parsed.json) return parsed;
                }
            }

            return { json: null, error: 'json_parse_failed' };
        }

        function buildStructuringInputText(ocrText) {
            const text = (ocrText || '').replace(/\r/g, '');
            const maxChars = 16000;
            if (text.length <= maxChars) return { text, truncated: false };

            const head = text.slice(0, 12000);
            const tail = text.slice(-2500);
            const keywordRegex = /(received|accepted|revised|available\s+online|published|submission|manuscript|doi|å½•ç”¨|æ¥å—|ä¿®è®¢|åœ¨çº¿|æ”¶åˆ°|æŠ•ç¨¿)/i;
            const lines = text.split('\n');
            const picked = [];
            const seen = new Set();
            for (let i = 0; i < lines.length; i++) {
                if (!keywordRegex.test(lines[i])) continue;
                for (let j = Math.max(0, i - 2); j <= Math.min(lines.length - 1, i + 2); j++) {
                    const line = lines[j].trim();
                    if (!line) continue;
                    if (seen.has(line)) continue;
                    seen.add(line);
                    picked.push(line);
                    if (picked.length >= 80) break;
                }
                if (picked.length >= 80) break;
            }

            const keywordsBlock = picked.length ? `\n\n[å…³é”®è¡Œæ‘˜å½•]\n${picked.join('\n')}` : '';
            const combined = `${head}\n\n[...OCRæ–‡æœ¬è¿‡é•¿å·²æˆªæ–­...]${keywordsBlock}\n\n[å°¾éƒ¨æ–‡æœ¬]\n${tail}`;
            return { text: combined.slice(0, maxChars), truncated: true };
        }

        function parseStructuredFromModelOutput(content) {
            const parsed = extractJsonFromText(content);
            let jsonData = parsed.json;
            let parseError = parsed.error;

            if (!jsonData && content) {
                jsonData = parseTextFormatOutput(content) || extractStructuredInfoFromText(content);
            }

            return {
                rawText: content,
                structured: jsonData,
                isStructured: !!jsonData,
                parseError: jsonData ? null : parseError
            };
        }

        // ç¬¬äºŒæ®µï¼šè°ƒç”¨LLMæ¨¡å‹å¯¹OCRæ–‡æœ¬åšç»“æ„åŒ–æ•´ç†
        async function structureTextWithLlm(ocrText, prompt = null) {
            const llmPrompt = prompt || getAcademicOcrPrompt();
            const llmModel = ocrConfig.llmModel || 'deepseek-v3.2';

            const { text: structInputText, truncated } = buildStructuringInputText(ocrText);
            console.log('[LLM-2] å¼€å§‹ç»“æ„åŒ–æ•´ç†... è¾“å…¥æ˜¯å¦æˆªæ–­:', truncated);

            const { content } = await callChatCompletions({
                model: llmModel,
                messages: [
                    { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªä¸¥è°¨çš„JSONä¿¡æ¯æŠ½å–å™¨ã€‚' },
                    { role: 'user', content: `${llmPrompt}\n\nOCRæ–‡æœ¬å¦‚ä¸‹ï¼š\n${structInputText}` }
                ],
                temperature: 0,
                max_tokens: 2048
            });

            const result = parseStructuredFromModelOutput(content);
            return { ...result, truncatedInput: truncated };
        }

        // OCRè¯†åˆ«å›¾ç‰‡
        async function ocrImage(imageDataUrl, prompt = null) {
            // å¦‚æœæ²¡æœ‰æä¾›promptï¼Œä½¿ç”¨é»˜è®¤çš„å­¦æœ¯æ–‡æ¡£æå–prompt
            if (!prompt) {
                prompt = getAcademicOcrPrompt();
            }
            try {
                console.log('å¼€å§‹OCRè¯†åˆ«...');

                // æå–base64å’ŒMIMEç±»å‹
                const match = imageDataUrl.match(/data:([^;]+);base64,(.+)/);
                if (!match) {
                    throw new Error('æ— æ•ˆçš„å›¾ç‰‡æ•°æ®URL');
                }

                const imageMimeType = match[1];
                const imageBase64 = match[2];

                // æ„å»ºAPIè¯·æ±‚ï¼ˆå‚è€ƒå®˜æ–¹æ–‡æ¡£æ ¼å¼ï¼‰
                const apiUrl = `${ocrConfig.baseUrl}/chat/completions`;
                const requestBody = {
                    model: ocrConfig.model,
                    messages: [
                        {
                            role: 'system',
                            content: 'ä½ æ˜¯ä¸“ä¸šè¯†åˆ«è®ºæ–‡ç›¸å…³ä¿¡æ¯çš„æ™ºèƒ½è¯†å›¾åŠ©æ‰‹ï¼Œå¯¹å›¾ç‰‡ä¸­çš„è®ºæ–‡ä¿¡æ¯è¿›è¡Œè¯†åˆ«ï¼Œå¹¶è¾“å‡ºJSONæ ¼å¼ã€‚'
                        },
                        {
                            role: 'user',
                            content: [
                                {
                                    type: 'text',
                                    text: prompt
                                },
                                {
                                    type: 'image_url',
                                    image_url: {
                                        url: imageDataUrl
                                    }
                                }
                            ]
                        }
                    ],
                    temperature: 0,
                    max_tokens: 6048,
                    stream: false
                };

                console.log('å‘é€OCRè¯·æ±‚åˆ°:', apiUrl);
                console.log('è¯·æ±‚å‚æ•°:', {
                    model: ocrConfig.model,
                    temperature: requestBody.temperature,
                    max_tokens: requestBody.max_tokens,
                    prompt_length: prompt.length,
                    has_system_message: requestBody.messages.some(m => m.role === 'system')
                });
                console.log('Promptå†…å®¹:', prompt);
                console.log('=== å®Œæ•´è¯·æ±‚æ•°æ® ===');
                console.log('è¯·æ±‚URL:', apiUrl);
                console.log('è¯·æ±‚Headers:', {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${ocrConfig.apiKey.substring(0, 10)}...`
                });
                console.log('å®Œæ•´è¯·æ±‚Body:', JSON.stringify(requestBody, null, 2));
                console.log('å›¾ç‰‡æ•°æ®URLé•¿åº¦:', imageDataUrl.length, 'å­—ç¬¦');
                console.log('å›¾ç‰‡æ•°æ®URLå‰100å­—ç¬¦:', imageDataUrl.substring(0, 100));
                console.log('==================');

                // å‘é€APIè¯·æ±‚
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${ocrConfig.apiKey}`
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`OCR APIè¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText} - ${errorText}`);
                }

                const data = await response.json();

                // æå–è¯†åˆ«ç»“æœ
                if (data.choices && data.choices.length > 0) {
                    const choice = data.choices[0];
                    let content = choice.message.content;
                    const finishReason = choice.finish_reason;

                    console.log('âœ“ OCRè¯†åˆ«å®Œæˆï¼Œæ–‡æœ¬é•¿åº¦:', content.length);
                    console.log('å®ŒæˆåŸå› :', finishReason);
                    if (finishReason === 'length') {
                        console.warn('[OCRè§£æ] è­¦å‘Šï¼šè¾“å‡ºå¯èƒ½å› tokené™åˆ¶è¢«æˆªæ–­ï¼');
                    }
                    console.log('OCRåŸå§‹è¾“å‡ºï¼ˆå®Œæ•´ï¼‰:', content);
                    console.log('OCRåŸå§‹è¾“å‡ºå‰500å­—ç¬¦:', content.substring(0, 500));
                    console.log('OCRåŸå§‹è¾“å‡ºå500å­—ç¬¦:', content.substring(Math.max(0, content.length - 500)));

                    // å¦‚æœè¾“å‡ºè¢«æˆªæ–­ï¼Œå°è¯•ä»å·²è¾“å‡ºçš„å†…å®¹ä¸­æå–ä¿¡æ¯
                    if (finishReason === 'length') {
                        console.warn('[OCRè§£æ] è¾“å‡ºè¢«æˆªæ–­ï¼Œå°è¯•ä»å·²è¾“å‡ºçš„å†…å®¹ä¸­æå–ä¿¡æ¯...');
                        // å³ä½¿è¢«æˆªæ–­ï¼Œä¹Ÿå°è¯•æå–æ ‡é¢˜ã€ä½œè€…å’Œæ—¥æœŸ
                    }

                    // æ£€æµ‹æ˜¯å¦æ˜¯é‡å¤å†…å®¹è¾“å‡ºï¼ˆæ¨¡å‹å¯èƒ½é‡å¤è¾“å‡ºç›¸åŒçš„å†…å®¹ï¼‰
                    const lines = content.split('\n').filter(line => line.trim().length > 0);
                    if (lines.length > 2) {
                        // æ£€æŸ¥æ˜¯å¦æœ‰å¤§é‡é‡å¤çš„è¡Œ
                        const lineCounts = {};
                        lines.forEach(line => {
                            const trimmed = line.trim();
                            if (trimmed.length > 5) {
                                // ä½¿ç”¨å‰50ä¸ªå­—ç¬¦ä½œä¸ºkeyï¼Œæ£€æµ‹ç›¸ä¼¼è¡Œï¼ˆå¢åŠ é•¿åº¦ä»¥æ›´å¥½åŒ¹é…ï¼‰
                                const key = trimmed.substring(0, Math.min(50, trimmed.length));
                                lineCounts[key] = (lineCounts[key] || 0) + 1;
                            }
                        });

                        // æ‰¾å‡ºå‡ºç°æ¬¡æ•°æœ€å¤šçš„è¡Œ
                        const maxCount = Math.max(...Object.values(lineCounts), 0);
                        const repeatedLine = Object.keys(lineCounts).find(key => lineCounts[key] === maxCount);

                        // é¢å¤–æ£€æŸ¥ï¼šå¦‚æœå‰å‡ è¡Œéƒ½ç›¸åŒï¼Œä¹Ÿæ˜¯é‡å¤
                        let prefixRepeatCount = 1;
                        if (lines.length >= 3) {
                            const firstLine = lines[0].trim().substring(0, Math.min(50, lines[0].trim().length));
                            for (let i = 1; i < Math.min(10, lines.length); i++) {
                                const currentLine = lines[i].trim().substring(0, Math.min(50, lines[i].trim().length));
                                if (currentLine === firstLine) {
                                    prefixRepeatCount++;
                                } else {
                                    break;
                                }
                            }
                        }

                        // ä½¿ç”¨æ›´å¤§çš„é‡å¤è®¡æ•°ï¼ˆè€ƒè™‘å‰ç¼€é‡å¤ï¼‰
                        const effectiveRepeatCount = Math.max(maxCount, prefixRepeatCount);

                        // å¦‚æœæŸä¸€è¡Œé‡å¤è¶…è¿‡2æ¬¡ï¼Œä¸”æ€»è¡Œæ•°è¶…è¿‡3è¡Œï¼Œè®¤ä¸ºæ˜¯å¼‚å¸¸è¾“å‡º
                        if (effectiveRepeatCount >= 2 && lines.length >= 3) {
                            console.warn('[OCRè§£æ] æ£€æµ‹åˆ°é‡å¤å†…å®¹è¾“å‡ºï¼Œé‡å¤è¡Œ:', repeatedLine || lines[0].trim().substring(0, 50));
                            console.warn('[OCRè§£æ] é‡å¤æ¬¡æ•°:', effectiveRepeatCount, 'æ€»è¡Œæ•°:', lines.length);
                            console.warn('[OCRè§£æ] è¿™å¯èƒ½æ˜¯æ¨¡å‹è¯†åˆ«é—®é¢˜ï¼Œæ¨¡å‹å¯èƒ½çœ‹åˆ°äº†å›¾ç‰‡ä¸­çš„æç¤ºæ–‡å­—å¹¶é‡å¤è¾“å‡ºã€‚');

                            // å¦‚æœé‡å¤æ¬¡æ•°è¿‡å¤šï¼ˆè¶…è¿‡2æ¬¡ï¼‰ï¼Œç›´æ¥å°è¯•æå–ä¿¡æ¯å¹¶è¿”å›ï¼Œä¸ç»§ç»­å¤„ç†
                            if (effectiveRepeatCount >= 2) {
                                console.log('[OCRè§£æ] é‡å¤æ¬¡æ•°è¿‡å¤šï¼Œå°è¯•ä»æ–‡æœ¬ä¸­æå–ä¿¡æ¯...');
                                const extractedDates = extractStructuredInfoFromText(content);
                                if (extractedDates && (extractedDates.dates || extractedDates.title !== 'Not mentioned' || extractedDates.authors !== 'Not mentioned')) {
                                    // å¦‚æœæå–åˆ°äº†ä¿¡æ¯ï¼Œè¿”å›æå–çš„ç»“æœè€Œä¸æ˜¯æŠ›å‡ºé”™è¯¯
                                    console.log('[OCRè§£æ] ä»é‡å¤è¾“å‡ºä¸­æå–åˆ°ä¿¡æ¯:', extractedDates);
                                    return {
                                        rawText: content.substring(0, 1000) + '... [è¾“å‡ºè¢«æˆªæ–­ï¼Œæ£€æµ‹åˆ°é‡å¤]',
                                        structured: {
                                            dates: extractedDates.dates || {},
                                            title: extractedDates.title || 'Not mentioned',
                                            authors: extractedDates.authors || 'Not mentioned'
                                        },
                                        isStructured: true,
                                        parseError: `æ£€æµ‹åˆ°é‡å¤è¾“å‡ºï¼ˆé‡å¤${effectiveRepeatCount}æ¬¡ï¼‰ï¼Œä½†å·²ä»æ–‡æœ¬ä¸­æå–ä¿¡æ¯`
                                    };
                                }

                                // å¦‚æœé‡å¤æ¬¡æ•°éå¸¸å¤šï¼ˆè¶…è¿‡5æ¬¡ï¼‰ï¼Œç›´æ¥æŠ›å‡ºé”™è¯¯
                                if (effectiveRepeatCount >= 5) {
                                    throw new Error(`OCRæ¨¡å‹è¾“å‡ºå¼‚å¸¸ï¼šæ£€æµ‹åˆ°ä¸¥é‡é‡å¤å†…å®¹è¾“å‡ºï¼ˆé‡å¤${effectiveRepeatCount}æ¬¡ï¼‰ã€‚æ¨¡å‹å¯èƒ½è¯†åˆ«åˆ°äº†å›¾ç‰‡ä¸­çš„æç¤ºæ–‡å­—å¹¶é™·å…¥å¾ªç¯ã€‚é‡å¤å†…å®¹ï¼š${(repeatedLine || lines[0].trim()).substring(0, 50)}...`);
                                }
                            }

                            // æ ‡è®°ä¸ºé”™è¯¯ï¼Œä½†ä¿ç•™åŸå§‹å†…å®¹ä¾›æŸ¥çœ‹
                            content = `[é”™è¯¯] æ£€æµ‹åˆ°é‡å¤è¾“å‡ºï¼ˆé‡å¤${effectiveRepeatCount}æ¬¡ï¼‰ï¼Œæ¨¡å‹å¯èƒ½è¯†åˆ«åˆ°äº†å›¾ç‰‡ä¸­çš„æç¤ºæ–‡å­—è€Œä¸æ˜¯å®é™…å†…å®¹ã€‚\n\né‡å¤çš„å†…å®¹ï¼š${repeatedLine || lines[0].trim()}\n\nåŸå§‹è¾“å‡ºå‰500å­—ç¬¦ï¼š\n${content.substring(0, 500)}...`;
                        }
                    }

                    // æ¸…ç†OCRè¾“å‡ºä¸­å¯èƒ½åŒ…å«çš„prompté‡å¤å†…å®¹
                    // ç§»é™¤é‡å¤çš„promptæ–‡æœ¬ï¼ˆå¦‚æœOCRæ¨¡å‹é”™è¯¯åœ°è¯†åˆ«äº†promptï¼‰
                    const promptKeywords = [
                        /^å¯é€‰è¯´æ˜\s*\n?/i,  // å¼€å¤´çš„"å¯é€‰è¯´æ˜"
                        /^è¯·è¯†åˆ«å›¾ç‰‡ä¸­çš„å­¦æœ¯æ–‡æ¡£ä¿¡æ¯[^\n]*/gi,
                        /^è¦æ±‚ï¼š[^\n]*/gi,
                        /^å¿…é¡»ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¾“å‡º[^\n]*/gi,
                        /^ç¤ºä¾‹ï¼š[^\n]*/gi,
                        /^é‡è¦ï¼šåªè¾“å‡ºJSONå¯¹è±¡[^\n]*/gi,
                        /^é‡è¦ï¼šå¿…é¡»åªè¾“å‡ºJSONå¯¹è±¡[^\n]*/gi,
                        /^ç¤ºä¾‹æ ¼å¼[^\n]*/gi,
                        /^document_type[^\n]*å½•ç”¨é€šçŸ¥[^\n]*è®ºæ–‡æ ‡é¢˜[^\n]*ä½œè€…[^\n]*dates[^\n]*received[^\n]*Not mentioned/gi,
                        /^åˆ†æå›¾ç‰‡ä¸­çš„å­¦æœ¯æ–‡æ¡£[^\n]*/gi,
                        /^ä½ æ˜¯å­¦æœ¯æ–‡æ¡£OCRè¯†åˆ«ä¸“å®¶[^\n]*/gi,
                        /^è¯·ä»”ç»†è¯†åˆ«å›¾ç‰‡ä¸­çš„æ‰€æœ‰æ–‡å­—å†…å®¹[^\n]*/gi,
                        /^é‡è¦æç¤º[^\n]*/gi,
                        /^æå–å­—æ®µ[^\n]*/gi,
                        /^è¯·ç¡®ä¿è¯†åˆ«å›¾ç‰‡çš„æ‰€æœ‰åŒºåŸŸ[^\n]*/gi,
                        /^åªè¾“å‡ºJSON[^\n]*/gi,
                        /^è¯†åˆ«å›¾ç‰‡ä¸­çš„æ ‡é¢˜ã€ä½œè€…ã€æ—¥æœŸ[^\n]*/gi,
                        /^è¾“å‡ºæ ¼å¼ç¤ºä¾‹[^\n]*/gi,
                        /^æ³¨æ„ï¼š[^\n]*/gi
                    ];

                    let cleanedContent = content;
                    for (const pattern of promptKeywords) {
                        const beforeLength = cleanedContent.length;
                        cleanedContent = cleanedContent.replace(pattern, '');
                        if (cleanedContent.length < beforeLength) {
                            console.log('[OCRè§£æ] ç§»é™¤promptæ®‹ç•™:', pattern.toString());
                        }
                    }

                    // ç§»é™¤å¼€å¤´çš„ç©ºè¡Œ
                    cleanedContent = cleanedContent.replace(/^\s*\n+/, '');

                    // å¦‚æœæ¸…ç†åå†…å®¹æ˜æ˜¾å˜çŸ­ï¼Œè¯´æ˜ç¡®å®æœ‰é‡å¤å†…å®¹
                    if (cleanedContent.length < content.length * 0.7) {
                        console.log('[OCRè§£æ] æ£€æµ‹åˆ°prompté‡å¤å†…å®¹ï¼Œå·²æ¸…ç†ï¼Œæ¸…ç†å‰é•¿åº¦:', content.length, 'æ¸…ç†åé•¿åº¦:', cleanedContent.length);
                        // å¦‚æœæ¸…ç†åå†…å®¹ä¸ºç©ºæˆ–å¤ªçŸ­ï¼Œè¯´æ˜æ•´ä¸ªè¾“å‡ºéƒ½æ˜¯prompté‡å¤ï¼Œå°è¯•ä»åŸå§‹å†…å®¹ä¸­æå–ä¿¡æ¯
                        if (cleanedContent.trim().length < 10) {
                            console.warn('[OCRè§£æ] æ¸…ç†åå†…å®¹ä¸ºç©ºï¼Œè¯´æ˜è¾“å‡ºå®Œå…¨æ˜¯prompté‡å¤ã€‚å°è¯•ä»åŸå§‹å†…å®¹ä¸­æå–ä¿¡æ¯...');
                            // å³ä½¿è¾“å‡ºæ˜¯prompté‡å¤ï¼Œä¹Ÿå°è¯•ä»æ–‡æœ¬ä¸­æå–ä¿¡æ¯ï¼ˆå¯èƒ½åŒ…å«ä¸€äº›æœ‰ç”¨çš„å†…å®¹ï¼‰
                            const extractedInfo = extractStructuredInfoFromText(content);
                            if (extractedInfo && (extractedInfo.title !== 'Not mentioned' || extractedInfo.authors !== 'Not mentioned' ||
                                Object.values(extractedInfo.dates || {}).some(d => d !== 'Not mentioned'))) {
                                console.log('[OCRè§£æ] ä»prompté‡å¤è¾“å‡ºä¸­æå–åˆ°ä¿¡æ¯:', extractedInfo);
                                return {
                                    rawText: content,
                                    structured: extractedInfo,
                                    isStructured: true,
                                    parseError: 'è¾“å‡ºæ˜¯prompté‡å¤ï¼Œä½†å·²ä»æ–‡æœ¬ä¸­æå–ä¿¡æ¯'
                                };
                            }
                        }
                        content = cleanedContent.trim();
                    } else if (cleanedContent !== content) {
                        // å³ä½¿å˜åŒ–ä¸å¤§ï¼Œä¹Ÿä½¿ç”¨æ¸…ç†åçš„å†…å®¹
                        content = cleanedContent.trim();
                        console.log('[OCRè§£æ] å·²æ¸…ç†promptæ®‹ç•™ï¼Œæ¸…ç†å‰é•¿åº¦:', content.length, 'æ¸…ç†åé•¿åº¦:', cleanedContent.length);
                    }

                    // å°è¯•è§£æJSONæ ¼å¼çš„ç»“æœ
                    let jsonData = null;
                    let parseError = null;
                    try {
                        // å…ˆå°è¯•æå–ä»£ç å—ä¸­çš„JSON
                        const jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/);
                        if (jsonMatch) {
                            jsonData = JSON.parse(jsonMatch[1]);
                            console.log('[OCRè§£æ] ä»jsonä»£ç å—è§£ææˆåŠŸ');
                        } else {
                            // å°è¯•æå–ä»£ç å—ï¼ˆæ— è¯­è¨€æ ‡è®°ï¼‰
                            const codeMatch = content.match(/```\s*([\s\S]*?)\s*```/);
                            if (codeMatch) {
                                try {
                                    jsonData = JSON.parse(codeMatch[1]);
                                    console.log('[OCRè§£æ] ä»ä»£ç å—è§£ææˆåŠŸ');
                                } catch (e) {
                                    console.warn('[OCRè§£æ] ä»£ç å—è§£æå¤±è´¥:', e);
                                }
                            }

                            // å¦‚æœä»£ç å—è§£æå¤±è´¥ï¼Œå°è¯•æå–JSONå¯¹è±¡ï¼ˆå¯èƒ½è¢«å…¶ä»–æ–‡å­—åŒ…å›´ï¼‰
                            if (!jsonData) {
                                // ä½¿ç”¨æ›´æ™ºèƒ½çš„æ–¹æ³•æŸ¥æ‰¾JSONå¯¹è±¡ï¼šä»ç¬¬ä¸€ä¸ª{å¼€å§‹ï¼Œæ‰¾åˆ°åŒ¹é…çš„}
                                let braceCount = 0;
                                let jsonStart = -1;
                                let jsonEnd = -1;

                                for (let i = 0; i < content.length; i++) {
                                    if (content[i] === '{') {
                                        if (braceCount === 0) {
                                            jsonStart = i;
                                        }
                                        braceCount++;
                                    } else if (content[i] === '}') {
                                        braceCount--;
                                        if (braceCount === 0 && jsonStart !== -1) {
                                            jsonEnd = i + 1;
                                            // å°è¯•è§£æè¿™ä¸ªJSONå¯¹è±¡
                                            try {
                                                const jsonStr = content.substring(jsonStart, jsonEnd);
                                                const parsed = JSON.parse(jsonStr);
                                                // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„å­¦æœ¯æ–‡æ¡£JSON
                                                if (parsed.document_type || parsed.title || parsed.authors || (parsed.dates && typeof parsed.dates === 'object')) {
                                                    // æ£€æŸ¥æ˜¯å¦åŒ…å«ç¤ºä¾‹æ–‡æœ¬ï¼Œå¦‚æœæ˜¯åˆ™å°è¯•ä»åç»­æ–‡æœ¬ä¸­æå–å®é™…å†…å®¹
                                                    const hasExampleText = parsed.title === "æå–çš„æ ‡é¢˜" || parsed.title === "å®é™…è®ºæ–‡æ ‡é¢˜" ||
                                                        parsed.authors === "æå–çš„ä½œè€…" || parsed.authors === "å®é™…ç¬¬ä¸€ä½œè€…å§“å" ||
                                                        (parsed.dates && (parsed.dates.received === "YYYY-MM-DD" || parsed.dates.received === "å®é™…æ—¥æœŸYYYY-MM-DD"));

                                                    if (hasExampleText) {
                                                        console.log('[OCRè§£æ] æ£€æµ‹åˆ°JSONåŒ…å«ç¤ºä¾‹æ–‡æœ¬ï¼Œå°è¯•ä»åç»­æ–‡æœ¬ä¸­æå–å®é™…å†…å®¹...');
                                                        // ä»JSONä¹‹åçš„æ–‡æœ¬ä¸­æå–å®é™…å†…å®¹
                                                        const textAfterJson = content.substring(jsonEnd);
                                                        const extractedInfo = extractStructuredInfoFromText(textAfterJson);
                                                        if (extractedInfo) {
                                                            // åˆå¹¶ï¼šç”¨å®é™…å†…å®¹æ›¿æ¢ç¤ºä¾‹æ–‡æœ¬
                                                            if (extractedInfo.title && extractedInfo.title !== 'Not mentioned') {
                                                                parsed.title = extractedInfo.title;
                                                            }
                                                            if (extractedInfo.authors && extractedInfo.authors !== 'Not mentioned') {
                                                                parsed.authors = extractedInfo.authors;
                                                            }
                                                            if (extractedInfo.dates) {
                                                                parsed.dates = { ...parsed.dates, ...extractedInfo.dates };
                                                            }
                                                            console.log('[OCRè§£æ] å·²ç”¨å®é™…å†…å®¹æ›¿æ¢ç¤ºä¾‹æ–‡æœ¬');
                                                        }
                                                    }
                                                    jsonData = parsed;
                                                    console.log('[OCRè§£æ] ä»æ–‡æœ¬ä¸­æå–JSONè§£ææˆåŠŸ');
                                                    break;
                                                }
                                            } catch (e) {
                                                // ç»§ç»­æŸ¥æ‰¾ä¸‹ä¸€ä¸ªJSONå¯¹è±¡
                                                jsonStart = -1;
                                                jsonEnd = -1;
                                            }
                                        }
                                    }
                                }

                                // å¦‚æœä¸Šé¢çš„æ–¹æ³•æ²¡æ‰¾åˆ°ï¼Œå°è¯•æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„JSONå¯¹è±¡
                                if (!jsonData) {
                                    const jsonMatches = content.match(/\{[\s\S]*?\}/g);
                                    if (jsonMatches && jsonMatches.length > 0) {
                                        // æŒ‰é•¿åº¦æ’åºï¼Œä¼˜å…ˆå°è¯•æœ€é•¿çš„ï¼ˆé€šå¸¸æ˜¯æœ€å®Œæ•´çš„ï¼‰
                                        jsonMatches.sort((a, b) => b.length - a.length);
                                        // å°è¯•è§£ææ¯ä¸ªåŒ¹é…çš„JSON
                                        for (const jsonStr of jsonMatches) {
                                            try {
                                                const parsed = JSON.parse(jsonStr);
                                                // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„å­¦æœ¯æ–‡æ¡£JSONï¼ˆåŒ…å«document_typeæˆ–titleå­—æ®µï¼‰
                                                if (parsed.document_type || parsed.title || parsed.authors || (parsed.dates && typeof parsed.dates === 'object')) {
                                                    // æ£€æŸ¥æ˜¯å¦åŒ…å«ç¤ºä¾‹æ–‡æœ¬ï¼Œå¦‚æœæ˜¯åˆ™å°è¯•ä»åç»­æ–‡æœ¬ä¸­æå–å®é™…å†…å®¹
                                                    const hasExampleText = parsed.title === "æå–çš„æ ‡é¢˜" || parsed.title === "å®é™…è®ºæ–‡æ ‡é¢˜" ||
                                                        parsed.authors === "æå–çš„ä½œè€…" || parsed.authors === "å®é™…ç¬¬ä¸€ä½œè€…å§“å" ||
                                                        (parsed.dates && (parsed.dates.received === "YYYY-MM-DD" || parsed.dates.received === "å®é™…æ—¥æœŸYYYY-MM-DD"));

                                                    if (hasExampleText) {
                                                        console.log('[OCRè§£æ] æ£€æµ‹åˆ°JSONåŒ…å«ç¤ºä¾‹æ–‡æœ¬ï¼ˆåŒ¹é…æ–¹æ³•ï¼‰ï¼Œå°è¯•ä»åç»­æ–‡æœ¬ä¸­æå–å®é™…å†…å®¹...');
                                                        // ä»JSONä¹‹åçš„æ–‡æœ¬ä¸­æå–å®é™…å†…å®¹
                                                        const jsonIndex = content.indexOf(jsonStr);
                                                        const textAfterJson = content.substring(jsonIndex + jsonStr.length);
                                                        const extractedInfo = extractStructuredInfoFromText(textAfterJson);
                                                        if (extractedInfo) {
                                                            // åˆå¹¶ï¼šç”¨å®é™…å†…å®¹æ›¿æ¢ç¤ºä¾‹æ–‡æœ¬
                                                            if (extractedInfo.title && extractedInfo.title !== 'Not mentioned') {
                                                                parsed.title = extractedInfo.title;
                                                            }
                                                            if (extractedInfo.authors && extractedInfo.authors !== 'Not mentioned') {
                                                                parsed.authors = extractedInfo.authors;
                                                            }
                                                            if (extractedInfo.dates) {
                                                                parsed.dates = { ...parsed.dates, ...extractedInfo.dates };
                                                            }
                                                            console.log('[OCRè§£æ] å·²ç”¨å®é™…å†…å®¹æ›¿æ¢ç¤ºä¾‹æ–‡æœ¬ï¼ˆåŒ¹é…æ–¹æ³•ï¼‰');
                                                        }
                                                    }
                                                    jsonData = parsed;
                                                    console.log('[OCRè§£æ] ä»æ–‡æœ¬ä¸­æå–JSONè§£ææˆåŠŸï¼ˆä½¿ç”¨åŒ¹é…æ–¹æ³•ï¼‰');
                                                    break;
                                                }
                                            } catch (e) {
                                                // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ª
                                            }
                                        }
                                    }
                                }
                            }

                            // å¦‚æœè¿˜æ˜¯æ²¡æ‰¾åˆ°ï¼Œå°è¯•ç›´æ¥è§£ææ•´ä¸ªå†…å®¹
                            if (!jsonData) {
                                try {
                                    jsonData = JSON.parse(content);
                                    console.log('[OCRè§£æ] ç›´æ¥è§£ææ•´ä¸ªå†…å®¹æˆåŠŸ');
                                } catch (e) {
                                    console.warn('[OCRè§£æ] ç›´æ¥è§£æå¤±è´¥:', e);
                                    parseError = e.message;
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('[OCRè§£æ] JSONè§£æå¤±è´¥:', e);
                        parseError = e.message;
                    }

                    // å¦‚æœJSONè§£æå¤±è´¥ï¼Œå°è¯•ä»æ–°çš„æ–‡æœ¬æ ¼å¼ä¸­æå–ç»“æ„åŒ–ä¿¡æ¯
                    if (!jsonData && content) {
                        console.log('[OCRè§£æ] JSONè§£æå¤±è´¥ï¼Œå°è¯•ä»æ–‡æœ¬æ ¼å¼ä¸­æå–ç»“æ„åŒ–ä¿¡æ¯...');
                        // å…ˆå°è¯•è§£ææ–°çš„æ–‡æœ¬æ ¼å¼
                        jsonData = parseTextFormatOutput(content);
                        if (jsonData) {
                            console.log('[OCRè§£æ] ä»æ–‡æœ¬æ ¼å¼æå–ç»“æ„åŒ–ä¿¡æ¯æˆåŠŸ:', jsonData);
                        } else {
                            // å¦‚æœæ–°æ ¼å¼è§£æå¤±è´¥ï¼Œå°è¯•æ—§çš„çº¯æ–‡æœ¬æå–æ–¹æ³•
                            jsonData = extractStructuredInfoFromText(content);
                            if (jsonData) {
                                console.log('[OCRè§£æ] ä»çº¯æ–‡æœ¬æå–ç»“æ„åŒ–ä¿¡æ¯æˆåŠŸ:', jsonData);
                            }
                        }
                    }

                    return {
                        rawText: content,
                        structured: jsonData,
                        isStructured: jsonData !== null,
                        parseError: parseError
                    };
                } else {
                    throw new Error('OCR APIè¿”å›ç»“æœä¸ºç©º');
                }
            } catch (error) {
                console.error('OCRè¯†åˆ«å¤±è´¥:', error);
                throw error;
            }
        }

        // æ˜¾ç¤ºç»“æœ
        function displayResult(fileName, result, isLast) {
            const resultSection = document.createElement('div');
            resultSection.className = 'result-section';

            let content = `
                <h3>ğŸ“„ ${fileName}</h3>
                <div class="result-item">
                    <span class="result-label">æ–‡ä»¶å¤§å°:</span>
                    <span class="result-value">${(result.fileSize / 1024).toFixed(2)} KB</span>
                </div>
            `;

            if (result.isPdf) {
                content += `
                    <div class="result-item">
                        <span class="result-label">æ€»é¡µæ•°:</span>
                        <span class="result-value">${result.totalPages}</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">æ˜¯å¦æ‰«æä»¶:</span>
                        <span class="result-value">${result.isScanned ? 'æ˜¯' : 'å¦'}</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">å¤„ç†æ–¹å¼:</span>
                        <span class="result-value">${result.message}</span>
                    </div>
                `;
            }

            if (result.imagePreview) {
                content += `
                    <h4>å›¾ç‰‡é¢„è§ˆ</h4>
                    <img src="${result.imagePreview}" alt="é¢„è§ˆ" class="preview-image">
                `;
            }

            if (result.ocrText) {
                const ocrData = typeof result.ocrText === 'object' ? result.ocrText : { rawText: result.ocrText, structured: null, isStructured: false };
                const rawText = ocrData.rawText || result.ocrText;

                content += `
	                    <h4>è¯†åˆ«ä¸æ•´ç†ç»“æœ</h4>
	                    <div class="success">âœ“ å¤„ç†æˆåŠŸï¼Œæ–‡æœ¬é•¿åº¦: ${rawText.length} å­—ç¬¦</div>
	                    <div class="result-item" style="background: #fff3cd; padding: 15px; border-radius: 4px; margin-top: 10px; border: 2px solid #ffc107;">
	                        <div style="margin-bottom: 10px;">
	                            <strong style="color: #856404;">è¾“å‡ºé•¿åº¦:</strong> <span style="color: #856404;">${rawText.length} å­—ç¬¦</span>
	                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong style="color: #856404;">æ˜¯å¦ç»“æ„åŒ–:</strong> <span style="color: #856404;">${ocrData.isStructured ? 'æ˜¯' : 'å¦'}</span>
                            ${ocrData.parseError ? ` <span style="color: #dc3545; font-weight: bold;">(è§£æé”™è¯¯: ${ocrData.parseError})</span>` : ''}
                        </div>
                        <div style="margin-top: 15px; margin-bottom: 10px;">
                            <strong style="color: #856404; font-size: 16px;">ğŸ“‹ å®Œæ•´åŸå§‹è¾“å‡ºï¼ˆæ¨¡å‹å›æ˜¾ï¼‰</strong>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 4px; max-height: 600px; overflow-y: auto; font-size: 13px; white-space: pre-wrap; word-wrap: break-word; border: 2px solid #ddd; font-family: 'Courier New', monospace; line-height: 1.6;">
                            ${escapeHtml(rawText)}
                        </div>
                    </div>
                `;

                // å¦‚æœæ˜¯ç»“æ„åŒ–æ•°æ®ï¼Œæ˜¾ç¤ºè§£æåçš„ä¿¡æ¯
                if (ocrData.isStructured && ocrData.structured) {
                    const structured = ocrData.structured;
                    content += `
                        <div class="result-section" style="margin-top: 15px; border-left-color: #28a745;">
                            <h4 style="color: #28a745;">ğŸ“‹ ç»“æ„åŒ–æå–ç»“æœ</h4>
                            <div class="result-item">
                                <span class="result-label">æ–‡æ¡£ç±»å‹:</span>
                                <span class="result-value">${structured.document_type || 'æœªè¯†åˆ«'}</span>
                            </div>
                            <div class="result-item">
                                <span class="result-label">æ ‡é¢˜:</span>
                                <span class="result-value">${structured.title || 'Not mentioned'}</span>
                            </div>
                            <div class="result-item">
                                <span class="result-label">ä½œè€…:</span>
                                <span class="result-value">${structured.authors || 'Not mentioned'}</span>
                            </div>
                            <h5 style="margin-top: 15px; color: #667eea;">æ—¥æœŸä¿¡æ¯</h5>
                            <div class="result-item">
                                <span class="result-label">æ”¶åˆ°æ—¥æœŸ (Received):</span>
                                <span class="result-value">${structured.dates?.received || 'Not mentioned'}</span>
                            </div>
                            <div class="result-item">
                                <span class="result-label">ä¿®è®¢æ—¥æœŸ (Revised):</span>
                                <span class="result-value">${structured.dates?.revised || 'Not mentioned'}</span>
                            </div>
                            <div class="result-item">
                                <span class="result-label">æ¥å—æ—¥æœŸ (Accepted):</span>
                                <span class="result-value">${structured.dates?.accepted || 'Not mentioned'}</span>
                            </div>
                            <div class="result-item">
                                <span class="result-label">åœ¨çº¿æ—¥æœŸ (Available online):</span>
                                <span class="result-value">${structured.dates?.available_online || 'Not mentioned'}</span>
                            </div>
                            ${structured.confidence_note ? `
                            <div class="result-item" style="background: #fff3cd; padding: 10px; border-radius: 4px; margin-top: 10px;">
                                <span class="result-label">ç½®ä¿¡åº¦è¯´æ˜:</span>
                                <span class="result-value">${structured.confidence_note}</span>
                            </div>
                            ` : ''}
                        </div>
                        <details style="margin-top: 15px;">
                            <summary style="cursor: pointer; color: #667eea; font-weight: bold;">æŸ¥çœ‹è§£æåçš„JSONæ•°æ®</summary>
                            <pre style="background: #f8f9fa; padding: 15px; border-radius: 4px; margin-top: 10px; max-height: 300px; overflow-y: auto; font-size: 12px;">${JSON.stringify(structured, null, 2)}</pre>
                        </details>
                    `;
                } else {
                    content += `
                        <div class="result-item" style="background: #f8d7da; padding: 10px; border-radius: 4px; margin-top: 10px;">
                            <span style="color: #721c24; font-weight: bold;">âš ï¸ æœªèƒ½è§£æä¸ºç»“æ„åŒ–æ•°æ®</span>
                            ${ocrData.parseError ? `<div style="margin-top: 5px; color: #721c24;">è§£æé”™è¯¯: ${ocrData.parseError}</div>` : ''}
                        </div>
                    `;
                }

                // äºŒæ®µå¼ï¼šå±•ç¤ºç¬¬ä¸€æ®µOCRåŸå§‹æ–‡æœ¬
                if (ocrData.ocrRawText) {
                    content += `
	                        <details style="margin-top: 15px;">
	                            <summary style="cursor: pointer; color: #667eea; font-weight: bold;">æŸ¥çœ‹æºæ–‡æœ¬ï¼ˆOCRæˆ–PDFæ–‡æœ¬æå–ï¼‰</summary>
	                            <pre style="background: #f8f9fa; padding: 15px; border-radius: 4px; margin-top: 10px; max-height: 300px; overflow-y: auto; font-size: 12px; white-space: pre-wrap; word-wrap: break-word;">${escapeHtml(ocrData.ocrRawText)}</pre>
	                        </details>
	                    `;
                }
            } else if (result.extractedText) {
                content += `
                    <h4>æå–çš„æ–‡æœ¬å†…å®¹</h4>
                    <div class="success">âœ“ æ–‡æœ¬æå–æˆåŠŸï¼Œæ–‡æœ¬é•¿åº¦: ${result.extractedText.length} å­—ç¬¦</div>
                    <pre>${result.extractedText}</pre>
                `;
            }

            resultSection.innerHTML = content;
            resultsDiv.appendChild(resultSection);
        }

        // æ˜¾ç¤ºé”™è¯¯
        function displayError(fileName, error) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.innerHTML = `
                <h3>âŒ ${fileName} å¤„ç†å¤±è´¥</h3>
                <p>${error.message || error}</p>
            `;
            resultsDiv.appendChild(errorDiv);
        }

        // HTMLè½¬ä¹‰å‡½æ•°
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>

</html>